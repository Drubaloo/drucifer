{"ast":null,"code":"import { BackSide, Color, ShaderMaterial, UniformsLib, UniformsUtils } from 'three';\n\n/**\n * Reference: https://en.wikipedia.org/wiki/Cel_shading\n *\n * API\n *\n * 1. Traditional\n *\n * const effect = new OutlineEffect( renderer );\n *\n * function render() {\n *\n * \teffect.render( scene, camera );\n *\n * }\n *\n * 2. VR compatible\n *\n * const effect = new OutlineEffect( renderer );\n * let renderingOutline = false;\n *\n * scene.onAfterRender = function () {\n *\n * \tif ( renderingOutline ) return;\n *\n * \trenderingOutline = true;\n *\n * \teffect.renderOutline( scene, camera );\n *\n * \trenderingOutline = false;\n *\n * };\n *\n * function render() {\n *\n * \trenderer.render( scene, camera );\n *\n * }\n *\n * // How to set default outline parameters\n * new OutlineEffect( renderer, {\n * \tdefaultThickness: 0.01,\n * \tdefaultColor: [ 0, 0, 0 ],\n * \tdefaultAlpha: 0.8,\n * \tdefaultKeepAlive: true // keeps outline material in cache even if material is removed from scene\n * } );\n *\n * // How to set outline parameters for each material\n * material.userData.outlineParameters = {\n * \tthickness: 0.01,\n * \tcolor: [ 0, 0, 0 ],\n * \talpha: 0.8,\n * \tvisible: true,\n * \tkeepAlive: true\n * };\n */\n\nclass OutlineEffect {\n  constructor(renderer) {\n    let parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.enabled = true;\n    const defaultThickness = parameters.defaultThickness !== undefined ? parameters.defaultThickness : 0.003;\n    const defaultColor = new Color().fromArray(parameters.defaultColor !== undefined ? parameters.defaultColor : [0, 0, 0]);\n    const defaultAlpha = parameters.defaultAlpha !== undefined ? parameters.defaultAlpha : 1.0;\n    const defaultKeepAlive = parameters.defaultKeepAlive !== undefined ? parameters.defaultKeepAlive : false;\n\n    // object.material.uuid -> outlineMaterial or\n    // object.material[ n ].uuid -> outlineMaterial\n    // save at the outline material creation and release\n    // if it's unused removeThresholdCount frames\n    // unless keepAlive is true.\n    const cache = {};\n    const removeThresholdCount = 60;\n\n    // outlineMaterial.uuid -> object.material or\n    // outlineMaterial.uuid -> object.material[ n ]\n    // save before render and release after render.\n    const originalMaterials = {};\n\n    // object.uuid -> originalOnBeforeRender\n    // save before render and release after render.\n    const originalOnBeforeRenders = {};\n\n    //this.cache = cache;  // for debug\n\n    const uniformsOutline = {\n      outlineThickness: {\n        value: defaultThickness\n      },\n      outlineColor: {\n        value: defaultColor\n      },\n      outlineAlpha: {\n        value: defaultAlpha\n      }\n    };\n    const vertexShader = ['#include <common>', '#include <uv_pars_vertex>', '#include <displacementmap_pars_vertex>', '#include <fog_pars_vertex>', '#include <morphtarget_pars_vertex>', '#include <skinning_pars_vertex>', '#include <logdepthbuf_pars_vertex>', '#include <clipping_planes_pars_vertex>', 'uniform float outlineThickness;', 'vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {', '\tfloat thickness = outlineThickness;', '\tconst float ratio = 1.0;',\n    // TODO: support outline thickness ratio for each vertex\n    '\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );',\n    // NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n    '\tvec4 norm = normalize( pos - pos2 );', '\treturn pos + norm * thickness * pos.w * ratio;', '}', 'void main() {', '\t#include <uv_vertex>', '\t#include <beginnormal_vertex>', '\t#include <morphnormal_vertex>', '\t#include <skinbase_vertex>', '\t#include <skinnormal_vertex>', '\t#include <begin_vertex>', '\t#include <morphtarget_vertex>', '\t#include <skinning_vertex>', '\t#include <displacementmap_vertex>', '\t#include <project_vertex>', '\tvec3 outlineNormal = - objectNormal;',\n    // the outline material is always rendered with BackSide\n\n    '\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );', '\t#include <logdepthbuf_vertex>', '\t#include <clipping_planes_vertex>', '\t#include <fog_vertex>', '}'].join('\\n');\n    const fragmentShader = ['#include <common>', '#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', '#include <clipping_planes_pars_fragment>', 'uniform vec3 outlineColor;', 'uniform float outlineAlpha;', 'void main() {', '\t#include <clipping_planes_fragment>', '\t#include <logdepthbuf_fragment>', '\tgl_FragColor = vec4( outlineColor, outlineAlpha );', '\t#include <tonemapping_fragment>', '\t#include <encodings_fragment>', '\t#include <fog_fragment>', '\t#include <premultiplied_alpha_fragment>', '}'].join('\\n');\n    function createMaterial() {\n      return new ShaderMaterial({\n        type: 'OutlineEffect',\n        uniforms: UniformsUtils.merge([UniformsLib['fog'], UniformsLib['displacementmap'], uniformsOutline]),\n        vertexShader: vertexShader,\n        fragmentShader: fragmentShader,\n        side: BackSide\n      });\n    }\n    function getOutlineMaterialFromCache(originalMaterial) {\n      let data = cache[originalMaterial.uuid];\n      if (data === undefined) {\n        data = {\n          material: createMaterial(),\n          used: true,\n          keepAlive: defaultKeepAlive,\n          count: 0\n        };\n        cache[originalMaterial.uuid] = data;\n      }\n      data.used = true;\n      return data.material;\n    }\n    function getOutlineMaterial(originalMaterial) {\n      const outlineMaterial = getOutlineMaterialFromCache(originalMaterial);\n      originalMaterials[outlineMaterial.uuid] = originalMaterial;\n      updateOutlineMaterial(outlineMaterial, originalMaterial);\n      return outlineMaterial;\n    }\n    function isCompatible(object) {\n      const geometry = object.geometry;\n      const hasNormals = geometry !== undefined && geometry.attributes.normal !== undefined;\n      return object.isMesh === true && object.material !== undefined && hasNormals === true;\n    }\n    function setOutlineMaterial(object) {\n      if (isCompatible(object) === false) return;\n      if (Array.isArray(object.material)) {\n        for (let i = 0, il = object.material.length; i < il; i++) {\n          object.material[i] = getOutlineMaterial(object.material[i]);\n        }\n      } else {\n        object.material = getOutlineMaterial(object.material);\n      }\n      originalOnBeforeRenders[object.uuid] = object.onBeforeRender;\n      object.onBeforeRender = onBeforeRender;\n    }\n    function restoreOriginalMaterial(object) {\n      if (isCompatible(object) === false) return;\n      if (Array.isArray(object.material)) {\n        for (let i = 0, il = object.material.length; i < il; i++) {\n          object.material[i] = originalMaterials[object.material[i].uuid];\n        }\n      } else {\n        object.material = originalMaterials[object.material.uuid];\n      }\n      object.onBeforeRender = originalOnBeforeRenders[object.uuid];\n    }\n    function onBeforeRender(renderer, scene, camera, geometry, material) {\n      const originalMaterial = originalMaterials[material.uuid];\n\n      // just in case\n      if (originalMaterial === undefined) return;\n      updateUniforms(material, originalMaterial);\n    }\n    function updateUniforms(material, originalMaterial) {\n      const outlineParameters = originalMaterial.userData.outlineParameters;\n      material.uniforms.outlineAlpha.value = originalMaterial.opacity;\n      if (outlineParameters !== undefined) {\n        if (outlineParameters.thickness !== undefined) material.uniforms.outlineThickness.value = outlineParameters.thickness;\n        if (outlineParameters.color !== undefined) material.uniforms.outlineColor.value.fromArray(outlineParameters.color);\n        if (outlineParameters.alpha !== undefined) material.uniforms.outlineAlpha.value = outlineParameters.alpha;\n      }\n      if (originalMaterial.displacementMap) {\n        material.uniforms.displacementMap.value = originalMaterial.displacementMap;\n        material.uniforms.displacementScale.value = originalMaterial.displacementScale;\n        material.uniforms.displacementBias.value = originalMaterial.displacementBias;\n      }\n    }\n    function updateOutlineMaterial(material, originalMaterial) {\n      if (material.name === 'invisible') return;\n      const outlineParameters = originalMaterial.userData.outlineParameters;\n      material.fog = originalMaterial.fog;\n      material.toneMapped = originalMaterial.toneMapped;\n      material.premultipliedAlpha = originalMaterial.premultipliedAlpha;\n      material.displacementMap = originalMaterial.displacementMap;\n      if (outlineParameters !== undefined) {\n        if (originalMaterial.visible === false) {\n          material.visible = false;\n        } else {\n          material.visible = outlineParameters.visible !== undefined ? outlineParameters.visible : true;\n        }\n        material.transparent = outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0 ? true : originalMaterial.transparent;\n        if (outlineParameters.keepAlive !== undefined) cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;\n      } else {\n        material.transparent = originalMaterial.transparent;\n        material.visible = originalMaterial.visible;\n      }\n      if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) material.visible = false;\n      if (originalMaterial.clippingPlanes) {\n        material.clipping = true;\n        material.clippingPlanes = originalMaterial.clippingPlanes;\n        material.clipIntersection = originalMaterial.clipIntersection;\n        material.clipShadows = originalMaterial.clipShadows;\n      }\n      material.version = originalMaterial.version; // update outline material if necessary\n    }\n\n    function cleanupCache() {\n      let keys;\n\n      // clear originialMaterials\n      keys = Object.keys(originalMaterials);\n      for (let i = 0, il = keys.length; i < il; i++) {\n        originalMaterials[keys[i]] = undefined;\n      }\n\n      // clear originalOnBeforeRenders\n      keys = Object.keys(originalOnBeforeRenders);\n      for (let i = 0, il = keys.length; i < il; i++) {\n        originalOnBeforeRenders[keys[i]] = undefined;\n      }\n\n      // remove unused outlineMaterial from cache\n      keys = Object.keys(cache);\n      for (let i = 0, il = keys.length; i < il; i++) {\n        const key = keys[i];\n        if (cache[key].used === false) {\n          cache[key].count++;\n          if (cache[key].keepAlive === false && cache[key].count > removeThresholdCount) {\n            delete cache[key];\n          }\n        } else {\n          cache[key].used = false;\n          cache[key].count = 0;\n        }\n      }\n    }\n    this.render = function (scene, camera) {\n      if (this.enabled === false) {\n        renderer.render(scene, camera);\n        return;\n      }\n      const currentAutoClear = renderer.autoClear;\n      renderer.autoClear = this.autoClear;\n      renderer.render(scene, camera);\n      renderer.autoClear = currentAutoClear;\n      this.renderOutline(scene, camera);\n    };\n    this.renderOutline = function (scene, camera) {\n      const currentAutoClear = renderer.autoClear;\n      const currentSceneAutoUpdate = scene.matrixWorldAutoUpdate;\n      const currentSceneBackground = scene.background;\n      const currentShadowMapEnabled = renderer.shadowMap.enabled;\n      scene.matrixWorldAutoUpdate = false;\n      scene.background = null;\n      renderer.autoClear = false;\n      renderer.shadowMap.enabled = false;\n      scene.traverse(setOutlineMaterial);\n      renderer.render(scene, camera);\n      scene.traverse(restoreOriginalMaterial);\n      cleanupCache();\n      scene.matrixWorldAutoUpdate = currentSceneAutoUpdate;\n      scene.background = currentSceneBackground;\n      renderer.autoClear = currentAutoClear;\n      renderer.shadowMap.enabled = currentShadowMapEnabled;\n    };\n\n    /*\n     * See #9918\n     *\n     * The following property copies and wrapper methods enable\n     * OutlineEffect to be called from other *Effect, like\n     *\n     * effect = new StereoEffect( new OutlineEffect( renderer ) );\n     *\n     * function render () {\n     *\n    \t * \teffect.render( scene, camera );\n     *\n     * }\n     */\n    this.autoClear = renderer.autoClear;\n    this.domElement = renderer.domElement;\n    this.shadowMap = renderer.shadowMap;\n    this.clear = function (color, depth, stencil) {\n      renderer.clear(color, depth, stencil);\n    };\n    this.getPixelRatio = function () {\n      return renderer.getPixelRatio();\n    };\n    this.setPixelRatio = function (value) {\n      renderer.setPixelRatio(value);\n    };\n    this.getSize = function (target) {\n      return renderer.getSize(target);\n    };\n    this.setSize = function (width, height, updateStyle) {\n      renderer.setSize(width, height, updateStyle);\n    };\n    this.setViewport = function (x, y, width, height) {\n      renderer.setViewport(x, y, width, height);\n    };\n    this.setScissor = function (x, y, width, height) {\n      renderer.setScissor(x, y, width, height);\n    };\n    this.setScissorTest = function (boolean) {\n      renderer.setScissorTest(boolean);\n    };\n    this.setRenderTarget = function (renderTarget) {\n      renderer.setRenderTarget(renderTarget);\n    };\n  }\n}\nexport { OutlineEffect };","map":{"version":3,"names":["BackSide","Color","ShaderMaterial","UniformsLib","UniformsUtils","OutlineEffect","constructor","renderer","parameters","arguments","length","undefined","enabled","defaultThickness","defaultColor","fromArray","defaultAlpha","defaultKeepAlive","cache","removeThresholdCount","originalMaterials","originalOnBeforeRenders","uniformsOutline","outlineThickness","value","outlineColor","outlineAlpha","vertexShader","join","fragmentShader","createMaterial","type","uniforms","merge","side","getOutlineMaterialFromCache","originalMaterial","data","uuid","material","used","keepAlive","count","getOutlineMaterial","outlineMaterial","updateOutlineMaterial","isCompatible","object","geometry","hasNormals","attributes","normal","isMesh","setOutlineMaterial","Array","isArray","i","il","onBeforeRender","restoreOriginalMaterial","scene","camera","updateUniforms","outlineParameters","userData","opacity","thickness","color","alpha","displacementMap","displacementScale","displacementBias","name","fog","toneMapped","premultipliedAlpha","visible","transparent","wireframe","depthTest","clippingPlanes","clipping","clipIntersection","clipShadows","version","cleanupCache","keys","Object","key","render","currentAutoClear","autoClear","renderOutline","currentSceneAutoUpdate","matrixWorldAutoUpdate","currentSceneBackground","background","currentShadowMapEnabled","shadowMap","traverse","domElement","clear","depth","stencil","getPixelRatio","setPixelRatio","getSize","target","setSize","width","height","updateStyle","setViewport","x","y","setScissor","setScissorTest","boolean","setRenderTarget","renderTarget"],"sources":["C:/Users/Dru/Documents/Personal Projects/threeJSBlenderBaby/node_modules/three/examples/jsm/effects/OutlineEffect.js"],"sourcesContent":["import {\n\tBackSide,\n\tColor,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils\n} from 'three';\n\n/**\n * Reference: https://en.wikipedia.org/wiki/Cel_shading\n *\n * API\n *\n * 1. Traditional\n *\n * const effect = new OutlineEffect( renderer );\n *\n * function render() {\n *\n * \teffect.render( scene, camera );\n *\n * }\n *\n * 2. VR compatible\n *\n * const effect = new OutlineEffect( renderer );\n * let renderingOutline = false;\n *\n * scene.onAfterRender = function () {\n *\n * \tif ( renderingOutline ) return;\n *\n * \trenderingOutline = true;\n *\n * \teffect.renderOutline( scene, camera );\n *\n * \trenderingOutline = false;\n *\n * };\n *\n * function render() {\n *\n * \trenderer.render( scene, camera );\n *\n * }\n *\n * // How to set default outline parameters\n * new OutlineEffect( renderer, {\n * \tdefaultThickness: 0.01,\n * \tdefaultColor: [ 0, 0, 0 ],\n * \tdefaultAlpha: 0.8,\n * \tdefaultKeepAlive: true // keeps outline material in cache even if material is removed from scene\n * } );\n *\n * // How to set outline parameters for each material\n * material.userData.outlineParameters = {\n * \tthickness: 0.01,\n * \tcolor: [ 0, 0, 0 ],\n * \talpha: 0.8,\n * \tvisible: true,\n * \tkeepAlive: true\n * };\n */\n\nclass OutlineEffect {\n\n\tconstructor( renderer, parameters = {} ) {\n\n\t\tthis.enabled = true;\n\n\t\tconst defaultThickness = parameters.defaultThickness !== undefined ? parameters.defaultThickness : 0.003;\n\t\tconst defaultColor = new Color().fromArray( parameters.defaultColor !== undefined ? parameters.defaultColor : [ 0, 0, 0 ] );\n\t\tconst defaultAlpha = parameters.defaultAlpha !== undefined ? parameters.defaultAlpha : 1.0;\n\t\tconst defaultKeepAlive = parameters.defaultKeepAlive !== undefined ? parameters.defaultKeepAlive : false;\n\n\t\t// object.material.uuid -> outlineMaterial or\n\t\t// object.material[ n ].uuid -> outlineMaterial\n\t\t// save at the outline material creation and release\n\t\t// if it's unused removeThresholdCount frames\n\t\t// unless keepAlive is true.\n\t\tconst cache = {};\n\n\t\tconst removeThresholdCount = 60;\n\n\t\t// outlineMaterial.uuid -> object.material or\n\t\t// outlineMaterial.uuid -> object.material[ n ]\n\t\t// save before render and release after render.\n\t\tconst originalMaterials = {};\n\n\t\t// object.uuid -> originalOnBeforeRender\n\t\t// save before render and release after render.\n\t\tconst originalOnBeforeRenders = {};\n\n\t\t//this.cache = cache;  // for debug\n\n\t\tconst uniformsOutline = {\n\t\t\toutlineThickness: { value: defaultThickness },\n\t\t\toutlineColor: { value: defaultColor },\n\t\t\toutlineAlpha: { value: defaultAlpha }\n\t\t};\n\n\t\tconst vertexShader = [\n\t\t\t'#include <common>',\n\t\t\t'#include <uv_pars_vertex>',\n\t\t\t'#include <displacementmap_pars_vertex>',\n\t\t\t'#include <fog_pars_vertex>',\n\t\t\t'#include <morphtarget_pars_vertex>',\n\t\t\t'#include <skinning_pars_vertex>',\n\t\t\t'#include <logdepthbuf_pars_vertex>',\n\t\t\t'#include <clipping_planes_pars_vertex>',\n\n\t\t\t'uniform float outlineThickness;',\n\n\t\t\t'vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {',\n\t\t\t'\tfloat thickness = outlineThickness;',\n\t\t\t'\tconst float ratio = 1.0;', // TODO: support outline thickness ratio for each vertex\n\t\t\t'\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );',\n\t\t\t// NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n\t\t\t'\tvec4 norm = normalize( pos - pos2 );',\n\t\t\t'\treturn pos + norm * thickness * pos.w * ratio;',\n\t\t\t'}',\n\n\t\t\t'void main() {',\n\n\t\t\t'\t#include <uv_vertex>',\n\n\t\t\t'\t#include <beginnormal_vertex>',\n\t\t\t'\t#include <morphnormal_vertex>',\n\t\t\t'\t#include <skinbase_vertex>',\n\t\t\t'\t#include <skinnormal_vertex>',\n\n\t\t\t'\t#include <begin_vertex>',\n\t\t\t'\t#include <morphtarget_vertex>',\n\t\t\t'\t#include <skinning_vertex>',\n\t\t\t'\t#include <displacementmap_vertex>',\n\t\t\t'\t#include <project_vertex>',\n\n\t\t\t'\tvec3 outlineNormal = - objectNormal;', // the outline material is always rendered with BackSide\n\n\t\t\t'\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );',\n\n\t\t\t'\t#include <logdepthbuf_vertex>',\n\t\t\t'\t#include <clipping_planes_vertex>',\n\t\t\t'\t#include <fog_vertex>',\n\n\t\t\t'}',\n\n\t\t].join( '\\n' );\n\n\t\tconst fragmentShader = [\n\n\t\t\t'#include <common>',\n\t\t\t'#include <fog_pars_fragment>',\n\t\t\t'#include <logdepthbuf_pars_fragment>',\n\t\t\t'#include <clipping_planes_pars_fragment>',\n\n\t\t\t'uniform vec3 outlineColor;',\n\t\t\t'uniform float outlineAlpha;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\t#include <clipping_planes_fragment>',\n\t\t\t'\t#include <logdepthbuf_fragment>',\n\n\t\t\t'\tgl_FragColor = vec4( outlineColor, outlineAlpha );',\n\n\t\t\t'\t#include <tonemapping_fragment>',\n\t\t\t'\t#include <encodings_fragment>',\n\t\t\t'\t#include <fog_fragment>',\n\t\t\t'\t#include <premultiplied_alpha_fragment>',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' );\n\n\t\tfunction createMaterial() {\n\n\t\t\treturn new ShaderMaterial( {\n\t\t\t\ttype: 'OutlineEffect',\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\t\tUniformsLib[ 'fog' ],\n\t\t\t\t\tUniformsLib[ 'displacementmap' ],\n\t\t\t\t\tuniformsOutline\n\t\t\t\t] ),\n\t\t\t\tvertexShader: vertexShader,\n\t\t\t\tfragmentShader: fragmentShader,\n\t\t\t\tside: BackSide\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction getOutlineMaterialFromCache( originalMaterial ) {\n\n\t\t\tlet data = cache[ originalMaterial.uuid ];\n\n\t\t\tif ( data === undefined ) {\n\n\t\t\t\tdata = {\n\t\t\t\t\tmaterial: createMaterial(),\n\t\t\t\t\tused: true,\n\t\t\t\t\tkeepAlive: defaultKeepAlive,\n\t\t\t\t\tcount: 0\n\t\t\t\t};\n\n\t\t\t\tcache[ originalMaterial.uuid ] = data;\n\n\t\t\t}\n\n\t\t\tdata.used = true;\n\n\t\t\treturn data.material;\n\n\t\t}\n\n\t\tfunction getOutlineMaterial( originalMaterial ) {\n\n\t\t\tconst outlineMaterial = getOutlineMaterialFromCache( originalMaterial );\n\n\t\t\toriginalMaterials[ outlineMaterial.uuid ] = originalMaterial;\n\n\t\t\tupdateOutlineMaterial( outlineMaterial, originalMaterial );\n\n\t\t\treturn outlineMaterial;\n\n\t\t}\n\n\t\tfunction isCompatible( object ) {\n\n\t\t\tconst geometry = object.geometry;\n\t\t\tconst hasNormals = ( geometry !== undefined ) && ( geometry.attributes.normal !== undefined );\n\n\t\t\treturn ( object.isMesh === true && object.material !== undefined && hasNormals === true );\n\n\t\t}\n\n\t\tfunction setOutlineMaterial( object ) {\n\n\t\t\tif ( isCompatible( object ) === false ) return;\n\n\t\t\tif ( Array.isArray( object.material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = object.material.length; i < il; i ++ ) {\n\n\t\t\t\t\tobject.material[ i ] = getOutlineMaterial( object.material[ i ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tobject.material = getOutlineMaterial( object.material );\n\n\t\t\t}\n\n\t\t\toriginalOnBeforeRenders[ object.uuid ] = object.onBeforeRender;\n\t\t\tobject.onBeforeRender = onBeforeRender;\n\n\t\t}\n\n\t\tfunction restoreOriginalMaterial( object ) {\n\n\t\t\tif ( isCompatible( object ) === false ) return;\n\n\t\t\tif ( Array.isArray( object.material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = object.material.length; i < il; i ++ ) {\n\n\t\t\t\t\tobject.material[ i ] = originalMaterials[ object.material[ i ].uuid ];\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tobject.material = originalMaterials[ object.material.uuid ];\n\n\t\t\t}\n\n\t\t\tobject.onBeforeRender = originalOnBeforeRenders[ object.uuid ];\n\n\t\t}\n\n\t\tfunction onBeforeRender( renderer, scene, camera, geometry, material ) {\n\n\t\t\tconst originalMaterial = originalMaterials[ material.uuid ];\n\n\t\t\t// just in case\n\t\t\tif ( originalMaterial === undefined ) return;\n\n\t\t\tupdateUniforms( material, originalMaterial );\n\n\t\t}\n\n\t\tfunction updateUniforms( material, originalMaterial ) {\n\n\t\t\tconst outlineParameters = originalMaterial.userData.outlineParameters;\n\n\t\t\tmaterial.uniforms.outlineAlpha.value = originalMaterial.opacity;\n\n\t\t\tif ( outlineParameters !== undefined ) {\n\n\t\t\t\tif ( outlineParameters.thickness !== undefined ) material.uniforms.outlineThickness.value = outlineParameters.thickness;\n\t\t\t\tif ( outlineParameters.color !== undefined ) material.uniforms.outlineColor.value.fromArray( outlineParameters.color );\n\t\t\t\tif ( outlineParameters.alpha !== undefined ) material.uniforms.outlineAlpha.value = outlineParameters.alpha;\n\n\t\t\t}\n\n\t\t\tif ( originalMaterial.displacementMap ) {\n\n\t\t\t\tmaterial.uniforms.displacementMap.value = originalMaterial.displacementMap;\n\t\t\t\tmaterial.uniforms.displacementScale.value = originalMaterial.displacementScale;\n\t\t\t\tmaterial.uniforms.displacementBias.value = originalMaterial.displacementBias;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction updateOutlineMaterial( material, originalMaterial ) {\n\n\t\t\tif ( material.name === 'invisible' ) return;\n\n\t\t\tconst outlineParameters = originalMaterial.userData.outlineParameters;\n\n\t\t\tmaterial.fog = originalMaterial.fog;\n\t\t\tmaterial.toneMapped = originalMaterial.toneMapped;\n\t\t\tmaterial.premultipliedAlpha = originalMaterial.premultipliedAlpha;\n\t\t\tmaterial.displacementMap = originalMaterial.displacementMap;\n\n\t\t\tif ( outlineParameters !== undefined ) {\n\n\t\t\t\tif ( originalMaterial.visible === false ) {\n\n\t\t\t\t\tmaterial.visible = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial.visible = ( outlineParameters.visible !== undefined ) ? outlineParameters.visible : true;\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.transparent = ( outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0 ) ? true : originalMaterial.transparent;\n\n\t\t\t\tif ( outlineParameters.keepAlive !== undefined ) cache[ originalMaterial.uuid ].keepAlive = outlineParameters.keepAlive;\n\n\t\t\t} else {\n\n\t\t\t\tmaterial.transparent = originalMaterial.transparent;\n\t\t\t\tmaterial.visible = originalMaterial.visible;\n\n\t\t\t}\n\n\t\t\tif ( originalMaterial.wireframe === true || originalMaterial.depthTest === false ) material.visible = false;\n\n\t\t\tif ( originalMaterial.clippingPlanes ) {\n\n\t\t\t\tmaterial.clipping = true;\n\n\t\t\t\tmaterial.clippingPlanes = originalMaterial.clippingPlanes;\n\t\t\t\tmaterial.clipIntersection = originalMaterial.clipIntersection;\n\t\t\t\tmaterial.clipShadows = originalMaterial.clipShadows;\n\n\t\t\t}\n\n\t\t\tmaterial.version = originalMaterial.version; // update outline material if necessary\n\n\t\t}\n\n\t\tfunction cleanupCache() {\n\n\t\t\tlet keys;\n\n\t\t\t// clear originialMaterials\n\t\t\tkeys = Object.keys( originalMaterials );\n\n\t\t\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\t\toriginalMaterials[ keys[ i ] ] = undefined;\n\n\t\t\t}\n\n\t\t\t// clear originalOnBeforeRenders\n\t\t\tkeys = Object.keys( originalOnBeforeRenders );\n\n\t\t\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\t\toriginalOnBeforeRenders[ keys[ i ] ] = undefined;\n\n\t\t\t}\n\n\t\t\t// remove unused outlineMaterial from cache\n\t\t\tkeys = Object.keys( cache );\n\n\t\t\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\t\tconst key = keys[ i ];\n\n\t\t\t\tif ( cache[ key ].used === false ) {\n\n\t\t\t\t\tcache[ key ].count ++;\n\n\t\t\t\t\tif ( cache[ key ].keepAlive === false && cache[ key ].count > removeThresholdCount ) {\n\n\t\t\t\t\t\tdelete cache[ key ];\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcache[ key ].used = false;\n\t\t\t\t\tcache[ key ].count = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tif ( this.enabled === false ) {\n\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst currentAutoClear = renderer.autoClear;\n\t\t\trenderer.autoClear = this.autoClear;\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t\trenderer.autoClear = currentAutoClear;\n\n\t\t\tthis.renderOutline( scene, camera );\n\n\t\t};\n\n\t\tthis.renderOutline = function ( scene, camera ) {\n\n\t\t\tconst currentAutoClear = renderer.autoClear;\n\t\t\tconst currentSceneAutoUpdate = scene.matrixWorldAutoUpdate;\n\t\t\tconst currentSceneBackground = scene.background;\n\t\t\tconst currentShadowMapEnabled = renderer.shadowMap.enabled;\n\n\t\t\tscene.matrixWorldAutoUpdate = false;\n\t\t\tscene.background = null;\n\t\t\trenderer.autoClear = false;\n\t\t\trenderer.shadowMap.enabled = false;\n\n\t\t\tscene.traverse( setOutlineMaterial );\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t\tscene.traverse( restoreOriginalMaterial );\n\n\t\t\tcleanupCache();\n\n\t\t\tscene.matrixWorldAutoUpdate = currentSceneAutoUpdate;\n\t\t\tscene.background = currentSceneBackground;\n\t\t\trenderer.autoClear = currentAutoClear;\n\t\t\trenderer.shadowMap.enabled = currentShadowMapEnabled;\n\n\t\t};\n\n\t\t/*\n\t\t * See #9918\n\t\t *\n\t\t * The following property copies and wrapper methods enable\n\t\t * OutlineEffect to be called from other *Effect, like\n\t\t *\n\t\t * effect = new StereoEffect( new OutlineEffect( renderer ) );\n\t\t *\n\t\t * function render () {\n\t\t *\n\t \t * \teffect.render( scene, camera );\n\t\t *\n\t\t * }\n\t\t */\n\t\tthis.autoClear = renderer.autoClear;\n\t\tthis.domElement = renderer.domElement;\n\t\tthis.shadowMap = renderer.shadowMap;\n\n\t\tthis.clear = function ( color, depth, stencil ) {\n\n\t\t\trenderer.clear( color, depth, stencil );\n\n\t\t};\n\n\t\tthis.getPixelRatio = function () {\n\n\t\t\treturn renderer.getPixelRatio();\n\n\t\t};\n\n\t\tthis.setPixelRatio = function ( value ) {\n\n\t\t\trenderer.setPixelRatio( value );\n\n\t\t};\n\n\t\tthis.getSize = function ( target ) {\n\n\t\t\treturn renderer.getSize( target );\n\n\t\t};\n\n\t\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\t\trenderer.setSize( width, height, updateStyle );\n\n\t\t};\n\n\t\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\t\trenderer.setViewport( x, y, width, height );\n\n\t\t};\n\n\t\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\t\trenderer.setScissor( x, y, width, height );\n\n\t\t};\n\n\t\tthis.setScissorTest = function ( boolean ) {\n\n\t\t\trenderer.setScissorTest( boolean );\n\n\t\t};\n\n\t\tthis.setRenderTarget = function ( renderTarget ) {\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\n\t\t};\n\n\t}\n\n}\n\nexport { OutlineEffect };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}