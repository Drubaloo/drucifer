{"ast":null,"code":"import { Pass, RenderPass, DepthPass, Effect, Selection } from 'postprocessing';\nimport { ShaderMaterial, Uniform, Vector2, Matrix3, TangentSpaceNormalMap, GLSL3, Matrix4, Vector3, WebGLRenderTarget, LinearFilter, HalfFloatType, WebGLMultipleRenderTargets, ShaderChunk, Color, Quaternion, VideoTexture, DataTexture, RGBAFormat, FloatType, NearestFilter, FramebufferTexture, WebGLCubeRenderTarget, CubeCamera, PMREMGenerator, Texture } from 'three';\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nvar boxBlur = \"#define GLSLIFY 1\\nuniform float blur;uniform float blurSharpness;uniform int blurKernel;vec3 denoise(vec3 center,sampler2D tex,vec2 uv,vec2 invTexSize,float blur,float blurSharpness,int blurKernel){vec3 color;float total;vec3 col;float weight;for(int x=-blurKernel;x<=blurKernel;x++){for(int y=-blurKernel;y<=blurKernel;y++){col=textureLod(tex,uv+vec2(x,y)*invTexSize,0.).rgb;weight=1.0-abs(dot(col-center,vec3(0.25)));weight=pow(weight,blurSharpness);color+=col*weight;total+=weight;}}return color/total;}\"; // eslint-disable-line\n\nvar finalSSRShader = \"#define GLSLIFY 1\\n#define MODE_DEFAULT 0\\n#define MODE_REFLECTIONS 1\\n#define MODE_RAW_REFLECTION 2\\n#define MODE_BLURRED_REFLECTIONS 3\\n#define MODE_INPUT 4\\n#define MODE_BLUR_MIX 5\\n#define FLOAT_EPSILON 0.00001\\nuniform sampler2D inputTexture;uniform sampler2D reflectionsTexture;uniform float samples;\\n#include <boxBlur>\\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 reflectionsTexel=texture2D(reflectionsTexture,vUv);ivec2 size=textureSize(reflectionsTexture,0);vec2 invTexSize=1./vec2(size.x,size.y);vec3 reflectionClr=reflectionsTexel.xyz;if(blur>FLOAT_EPSILON){vec3 blurredReflectionsColor=denoise(reflectionsTexel.rgb,reflectionsTexture,vUv,invTexSize,blur,blurSharpness,blurKernel);reflectionClr=mix(reflectionClr,blurredReflectionsColor.rgb,blur);}\\n#if RENDER_MODE == MODE_DEFAULT\\noutputColor=vec4(inputColor.rgb+reflectionClr,1.0);\\n#endif\\n#if RENDER_MODE == MODE_REFLECTIONS\\noutputColor=vec4(reflectionClr,1.0);\\n#endif\\n#if RENDER_MODE == MODE_RAW_REFLECTION\\noutputColor=vec4(reflectionsTexel.xyz,1.0);\\n#endif\\n#if RENDER_MODE == MODE_BLURRED_REFLECTIONS\\noutputColor=vec4(blurredReflectionsTexel.xyz,1.0);\\n#endif\\n#if RENDER_MODE == MODE_INPUT\\noutputColor=vec4(inputColor.xyz,1.0);\\n#endif\\n#if RENDER_MODE == MODE_BLUR_MIX\\noutputColor=vec4(vec3(blur),1.0);\\n#endif\\n}\"; // eslint-disable-line\n\nvar helperFunctions = \"#define GLSLIFY 1\\nvec3 getViewPosition(const float depth){float clipW=_projectionMatrix[2][3]*depth+_projectionMatrix[3][3];vec4 clipPosition=vec4((vec3(vUv,depth)-0.5)*2.0,1.0);clipPosition*=clipW;return(_inverseProjectionMatrix*clipPosition).xyz;}float getViewZ(const in float depth){\\n#ifdef PERSPECTIVE_CAMERA\\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\\n#else\\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\\n#endif\\n}vec3 screenSpaceToWorldSpace(const vec2 uv,const float depth){vec4 ndc=vec4((uv.x-0.5)*2.0,(uv.y-0.5)*2.0,(depth-0.5)*2.0,1.0);vec4 clip=_inverseProjectionMatrix*ndc;vec4 view=cameraMatrixWorld*(clip/clip.w);return view.xyz;}\\n#define Scale (vec3(0.8, 0.8, 0.8))\\n#define K (19.19)\\nvec3 hash(vec3 a){a=fract(a*Scale);a+=dot(a,a.yxz+K);return fract((a.xxy+a.yxx)*a.zyx);}float fresnel_dielectric_cos(float cosi,float eta){float c=abs(cosi);float g=eta*eta-1.0+c*c;float result;if(g>0.0){g=sqrt(g);float A=(g-c)/(g+c);float B=(c*(g+c)-1.0)/(c*(g-c)+1.0);result=0.5*A*A*(1.0+B*B);}else{result=1.0;}return result;}float fresnel_dielectric(vec3 Incoming,vec3 Normal,float eta){float cosine=dot(Incoming,Normal);return min(1.0,5.0*fresnel_dielectric_cos(cosine,eta));}\"; // eslint-disable-line\n\nvar trCompose = \"#define GLSLIFY 1\\n#define INV_EULER 0.36787944117144233\\nalpha=velocityDisocclusion<FLOAT_EPSILON ?(alpha+0.0075): 0.0;alpha=clamp(alpha,0.0,1.0);bool needsBlur=!didReproject||velocityDisocclusion>0.5;\\n#ifdef boxBlur\\nif(needsBlur)inputColor=boxBlurredColor;\\n#endif\\nif(alpha==1.0){outputColor=accumulatedColor;}else{float m=mix(alpha,1.0,blend);if(needsBlur)m=0.0;outputColor=accumulatedColor*m+inputColor*(1.0-m);}\"; // eslint-disable-line\n\n// WebGL2: will render normals to RGB channel of \"gNormal\" buffer, roughness to A channel of \"gNormal\" buffer, depth to RGBA channel of \"gDepth\" buffer\n// and velocity to \"gVelocity\" buffer\n\nclass MRTMaterial extends ShaderMaterial {\n  constructor() {\n    super({\n      type: \"MRTMaterial\",\n      defines: {\n        USE_UV: \"\",\n        TEMPORAL_RESOLVE: \"\"\n      },\n      uniforms: {\n        opacity: new Uniform(1),\n        normalMap: new Uniform(null),\n        normalScale: new Uniform(new Vector2(1, 1)),\n        uvTransform: new Uniform(new Matrix3()),\n        roughness: new Uniform(1),\n        roughnessMap: new Uniform(null)\n      },\n      vertexShader: /* glsl */\n      `\n                #ifdef USE_MRT\n                 varying vec2 vHighPrecisionZW;\n                #endif\n                #define NORMAL\n                #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n                    varying vec3 vViewPosition;\n                #endif\n                #include <common>\n                #include <uv_pars_vertex>\n                #include <displacementmap_pars_vertex>\n                #include <normal_pars_vertex>\n                #include <morphtarget_pars_vertex>\n                #include <skinning_pars_vertex>\n                #include <logdepthbuf_pars_vertex>\n                #include <clipping_planes_pars_vertex>\n                void main() {\n                    #include <uv_vertex>\n                    #include <beginnormal_vertex>\n                    #include <morphnormal_vertex>\n                    #include <skinbase_vertex>\n                    #include <skinnormal_vertex>\n                    #include <defaultnormal_vertex>\n                    #include <normal_vertex>\n                    #include <begin_vertex>\n                    #include <morphtarget_vertex>\n                    #include <skinning_vertex>\n                    #include <displacementmap_vertex>\n                    #include <project_vertex>\n                    #include <logdepthbuf_vertex>\n                    #include <clipping_planes_vertex>\n                    #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n                        vViewPosition = - mvPosition.xyz;\n                    #endif\n                    #ifdef USE_MRT\n                        vHighPrecisionZW = gl_Position.zw;\n                    #endif \n                    #ifdef USE_UV\n                        vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n                    #endif\n                }\n            `,\n      fragmentShader: /* glsl */\n      `\n                 #define NORMAL\n                #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n                    varying vec3 vViewPosition;\n                #endif\n                #include <packing>\n                #include <uv_pars_fragment>\n                #include <normal_pars_fragment>\n                #include <bumpmap_pars_fragment>\n                #include <normalmap_pars_fragment>\n                #include <logdepthbuf_pars_fragment>\n                #include <clipping_planes_pars_fragment>\n                #include <roughnessmap_pars_fragment>\n                \n                #ifdef USE_MRT\n                layout(location = 0) out vec4 gNormal;\n                layout(location = 1) out vec4 gDepth;\n                \n                varying vec2 vHighPrecisionZW;\n                #endif\n                uniform float roughness;\n                void main() {\n                    #include <clipping_planes_fragment>\n                    #include <logdepthbuf_fragment>\n                    #include <normal_fragment_begin>\n                    #include <normal_fragment_maps>\n\n                    float roughnessFactor = roughness;\n                    \n                    if(roughness > 10.0e9){\n                        roughnessFactor = 1.;\n                    }else{\n                        #ifdef useRoughnessMap\n                            vec4 texelRoughness = texture2D( roughnessMap, vUv );\n                            // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n                            roughnessFactor *= texelRoughness.g;\n                        #endif\n                    }\n\n                    vec3 normalColor = packNormalToRGB( normal );\n                    #ifdef USE_MRT\n                        float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n                        vec4 depthColor = packDepthToRGBA( fragCoordZ );\n                        gNormal = vec4( normalColor, roughnessFactor );\n                        gDepth = depthColor;\n                    #else\n                        gl_FragColor = vec4(normalColor, roughnessFactor);\n                    #endif\n                }\n            `,\n      toneMapped: false\n    });\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    Object.defineProperty(this, \"glslVersion\", {\n      get() {\n        return \"USE_MRT\" in this.defines ? GLSL3 : null;\n      },\n      set(_) {}\n    });\n  }\n}\nvar vertexShader$1 = \"#define GLSLIFY 1\\nvarying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}\"; // eslint-disable-line\n\nvar fragmentShader = \"#define GLSLIFY 1\\nvarying vec2 vUv;uniform sampler2D inputTexture;uniform sampler2D accumulatedTexture;uniform sampler2D normalTexture;uniform sampler2D depthTexture;uniform sampler2D envMap;uniform mat4 _projectionMatrix;uniform mat4 _inverseProjectionMatrix;uniform mat4 cameraMatrixWorld;uniform float cameraNear;uniform float cameraFar;uniform float rayDistance;uniform float intensity;uniform float maxDepthDifference;uniform float roughnessFade;uniform float maxRoughness;uniform float fade;uniform float thickness;uniform float ior;uniform float samples;uniform float jitter;uniform float jitterRoughness;\\n#define INVALID_RAY_COORDS vec2(-1.0);\\n#define EARLY_OUT_COLOR vec4(0.0, 0.0, 0.0, 1.0)\\n#define FLOAT_EPSILON 0.00001\\nfloat nearMinusFar;float nearMulFar;float farMinusNear;\\n#include <packing>\\n#include <helperFunctions>\\nvec2 RayMarch(vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference);vec2 BinarySearch(in vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference);float fastGetViewZ(const in float depth);vec3 getIBLRadiance(const in vec3 viewDir,const in vec3 normal,const in float roughness);void main(){vec4 depthTexel=textureLod(depthTexture,vUv,0.0);if(dot(depthTexel.rgb,depthTexel.rgb)<FLOAT_EPSILON){gl_FragColor=EARLY_OUT_COLOR;return;}float unpackedDepth=unpackRGBAToDepth(depthTexel);vec4 normalTexel=textureLod(normalTexture,vUv,0.0);float roughness=normalTexel.a;float specular=1.0-roughness;nearMinusFar=cameraNear-cameraFar;nearMulFar=cameraNear*cameraFar;farMinusNear=cameraFar-cameraNear;normalTexel.rgb=unpackRGBToNormal(normalTexel.rgb);float depth=fastGetViewZ(unpackedDepth);vec3 viewPos=getViewPosition(depth);vec3 viewDir=normalize(viewPos);vec3 viewNormal=normalTexel.xyz;vec3 worldPos=screenSpaceToWorldSpace(vUv,unpackedDepth);vec3 jitt=vec3(0.0);if(jitterRoughness!=0.0||jitter!=0.0){vec3 randomJitter=hash(50.0*samples*worldPos)-0.5;float spread=((2.0-specular)+roughness*jitterRoughness);float jitterMix=jitter*0.25+jitterRoughness*roughness;if(jitterMix>1.0)jitterMix=1.0;jitt=mix(vec3(0.0),randomJitter*spread,jitterMix);}viewNormal+=jitt;float fresnelFactor=fresnel_dielectric(viewDir,viewNormal,ior);vec3 iblRadiance=getIBLRadiance(-viewDir,viewNormal,0.)*fresnelFactor;float lastFrameAlpha=textureLod(accumulatedTexture,vUv,0.0).a;if(roughness>maxRoughness||(roughness>1.0-FLOAT_EPSILON&&roughnessFade>1.0-FLOAT_EPSILON)){gl_FragColor=vec4(iblRadiance,lastFrameAlpha);return;}vec3 reflected=reflect(viewDir,viewNormal);vec3 rayDir=reflected*-viewPos.z;vec3 hitPos=viewPos;float rayHitDepthDifference;vec2 coords=RayMarch(rayDir,hitPos,rayHitDepthDifference);if(coords.x==-1.0){gl_FragColor=vec4(iblRadiance,lastFrameAlpha);return;}vec4 SSRTexel=textureLod(inputTexture,coords.xy,0.0);vec4 SSRTexelReflected=textureLod(accumulatedTexture,coords.xy,0.0);vec3 SSR=SSRTexel.rgb+SSRTexelReflected.rgb;float roughnessFactor=mix(specular,1.0,max(0.0,1.0-roughnessFade));vec2 coordsNDC=(coords.xy*2.0-1.0);float screenFade=0.1;float maxDimension=min(1.0,max(abs(coordsNDC.x),abs(coordsNDC.y)));float reflectionIntensity=1.0-(max(0.0,maxDimension-screenFade)/(1.0-screenFade));reflectionIntensity=max(0.,reflectionIntensity);vec3 finalSSR=mix(iblRadiance,SSR,reflectionIntensity)*roughnessFactor;if(fade!=0.0){vec3 hitWorldPos=screenSpaceToWorldSpace(coords,rayHitDepthDifference);float reflectionDistance=distance(hitWorldPos,worldPos)+1.0;float opacity=1.0/(reflectionDistance*fade*0.1);if(opacity>1.0)opacity=1.0;finalSSR*=opacity;}finalSSR*=fresnelFactor*intensity;finalSSR=min(vec3(1.0),finalSSR);float alpha=hitPos.z==1.0 ? 1.0 : SSRTexelReflected.a;alpha=min(lastFrameAlpha,alpha);gl_FragColor=vec4(finalSSR,alpha);}vec2 RayMarch(vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference){dir=normalize(dir);dir*=rayDistance/float(steps);float depth;vec4 projectedCoord;vec4 lastProjectedCoord;float unpackedDepth;vec4 depthTexel;for(int i=0;i<steps;i++){hitPos+=dir;projectedCoord=_projectionMatrix*vec4(hitPos,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;\\n#ifndef missedRays\\nif(projectedCoord.x<0.0||projectedCoord.x>1.0||projectedCoord.y<0.0||projectedCoord.y>1.0){return INVALID_RAY_COORDS;}\\n#endif\\ndepthTexel=textureLod(depthTexture,projectedCoord.xy,0.0);unpackedDepth=unpackRGBAToDepth(depthTexel);depth=fastGetViewZ(unpackedDepth);rayHitDepthDifference=depth-hitPos.z;if(rayHitDepthDifference>=0.0&&rayHitDepthDifference<thickness){\\n#if refineSteps == 0\\nif(dot(depthTexel.rgb,depthTexel.rgb)<FLOAT_EPSILON)return INVALID_RAY_COORDS;\\n#else\\nreturn BinarySearch(dir,hitPos,rayHitDepthDifference);\\n#endif\\n}\\n#ifndef missedRays\\nif(hitPos.z>0.0){return INVALID_RAY_COORDS;}\\n#endif\\nlastProjectedCoord=projectedCoord;}hitPos.z=1.0;\\n#ifndef missedRays\\nreturn INVALID_RAY_COORDS;\\n#endif\\nrayHitDepthDifference=unpackedDepth;return projectedCoord.xy;}vec2 BinarySearch(in vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference){float depth;vec4 projectedCoord;vec2 lastMinProjectedCoordXY;float unpackedDepth;vec4 depthTexel;for(int i=0;i<refineSteps;i++){projectedCoord=_projectionMatrix*vec4(hitPos,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;depthTexel=textureLod(depthTexture,projectedCoord.xy,0.0);unpackedDepth=unpackRGBAToDepth(depthTexel);depth=fastGetViewZ(unpackedDepth);rayHitDepthDifference=depth-hitPos.z;dir*=0.5;if(rayHitDepthDifference>0.0){hitPos-=dir;}else{hitPos+=dir;}}if(dot(depthTexel.rgb,depthTexel.rgb)<FLOAT_EPSILON)return INVALID_RAY_COORDS;if(abs(rayHitDepthDifference)>maxDepthDifference)return INVALID_RAY_COORDS;projectedCoord=_projectionMatrix*vec4(hitPos,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;rayHitDepthDifference=unpackedDepth;return projectedCoord.xy;}float fastGetViewZ(const in float depth){\\n#ifdef PERSPECTIVE_CAMERA\\nreturn nearMulFar/(farMinusNear*depth-cameraFar);\\n#else\\nreturn depth*nearMinusFar-cameraNear;\\n#endif\\n}\\n#include <common>\\n#include <cube_uv_reflection_fragment>\\nvec3 getIBLRadiance(const in vec3 viewDir,const in vec3 normal,const in float roughness){\\n#if defined(ENVMAP_TYPE_CUBE_UV)\\nvec3 reflectVec=reflect(-viewDir,normal);reflectVec=normalize(mix(reflectVec,normal,roughness*roughness));reflectVec=inverseTransformDirection(reflectVec,viewMatrix);vec4 envMapColor=textureCubeUV(envMap,reflectVec,roughness);return envMapColor.rgb*intensity;\\n#else\\nreturn vec3(0.0);\\n#endif\\n}\"; // eslint-disable-line\n\nclass ReflectionsMaterial extends ShaderMaterial {\n  constructor() {\n    super({\n      type: \"ReflectionsMaterial\",\n      uniforms: {\n        inputTexture: new Uniform(null),\n        accumulatedTexture: new Uniform(null),\n        normalTexture: new Uniform(null),\n        depthTexture: new Uniform(null),\n        _projectionMatrix: new Uniform(new Matrix4()),\n        _inverseProjectionMatrix: new Uniform(new Matrix4()),\n        cameraMatrixWorld: new Uniform(new Matrix4()),\n        cameraNear: new Uniform(0),\n        cameraFar: new Uniform(0),\n        rayDistance: new Uniform(0),\n        intensity: new Uniform(0),\n        roughnessFade: new Uniform(0),\n        fade: new Uniform(0),\n        thickness: new Uniform(0),\n        ior: new Uniform(0),\n        maxDepthDifference: new Uniform(0),\n        jitter: new Uniform(0),\n        jitterRoughness: new Uniform(0),\n        maxRoughness: new Uniform(0),\n        samples: new Uniform(0),\n        envMap: new Uniform(null),\n        envMapPosition: new Uniform(new Vector3()),\n        envMapSize: new Uniform(new Vector3()),\n        viewMatrix: new Uniform(new Matrix4())\n      },\n      defines: {\n        steps: 20,\n        refineSteps: 5,\n        CUBEUV_TEXEL_WIDTH: 0,\n        CUBEUV_TEXEL_HEIGHT: 0,\n        CUBEUV_MAX_MIP: 0,\n        vWorldPosition: \"worldPos\"\n      },\n      fragmentShader: fragmentShader.replace(\"#include <helperFunctions>\", helperFunctions),\n      vertexShader: vertexShader$1,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false\n    });\n  }\n}\nconst getVisibleChildren = object => {\n  const queue = [object];\n  const objects = [];\n  while (queue.length !== 0) {\n    const mesh = queue.shift();\n    if (mesh.material) objects.push(mesh);\n    for (const c of mesh.children) {\n      if (c.visible) queue.push(c);\n    }\n  }\n  return objects;\n};\nconst generateCubeUVSize = parameters => {\n  const imageHeight = parameters.envMapCubeUVHeight;\n  if (imageHeight === null) return null;\n  const maxMip = Math.log2(imageHeight) - 2;\n  const texelHeight = 1.0 / imageHeight;\n  const texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));\n  return {\n    texelWidth,\n    texelHeight,\n    maxMip\n  };\n};\nconst setupEnvMap = (reflectionsMaterial, envMap, envMapCubeUVHeight) => {\n  reflectionsMaterial.uniforms.envMap.value = envMap;\n  const envMapCubeUVSize = generateCubeUVSize({\n    envMapCubeUVHeight\n  });\n  reflectionsMaterial.defines.ENVMAP_TYPE_CUBE_UV = \"\";\n  reflectionsMaterial.defines.CUBEUV_TEXEL_WIDTH = envMapCubeUVSize.texelWidth;\n  reflectionsMaterial.defines.CUBEUV_TEXEL_HEIGHT = envMapCubeUVSize.texelHeight;\n  reflectionsMaterial.defines.CUBEUV_MAX_MIP = envMapCubeUVSize.maxMip + \".0\";\n  reflectionsMaterial.needsUpdate = true;\n};\nconst isWebGL2Available = () => {\n  try {\n    const canvas = document.createElement(\"canvas\");\n    return !!(window.WebGL2RenderingContext && canvas.getContext(\"webgl2\"));\n  } catch (e) {\n    return false;\n  }\n};\nclass ReflectionsPass extends Pass {\n  constructor(ssrEffect) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(\"ReflectionsPass\");\n    this.ssrEffect = void 0;\n    this.cachedMaterials = new WeakMap();\n    this.USE_MRT = false;\n    this.webgl1DepthPass = null;\n    this.visibleMeshes = [];\n    this.ssrEffect = ssrEffect;\n    this._scene = ssrEffect._scene;\n    this._camera = ssrEffect._camera;\n    this.fullscreenMaterial = new ReflectionsMaterial();\n    if (ssrEffect._camera.isPerspectiveCamera) this.fullscreenMaterial.defines.PERSPECTIVE_CAMERA = \"\";\n    const width = options.width || typeof window !== \"undefined\" ? window.innerWidth : 2000;\n    const height = options.height || typeof window !== \"undefined\" ? window.innerHeight : 1000;\n    this.renderTarget = new WebGLRenderTarget(width, height, {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      type: HalfFloatType,\n      depthBuffer: false\n    });\n    this.renderPass = new RenderPass(this._scene, this._camera);\n    this.USE_MRT = isWebGL2Available();\n    if (this.USE_MRT) {\n      // buffers: normal, depth (2), roughness will be written to the alpha channel of the normal buffer\n      this.gBuffersRenderTarget = new WebGLMultipleRenderTargets(width, height, 2, {\n        minFilter: LinearFilter,\n        magFilter: LinearFilter\n      });\n      this.normalTexture = this.gBuffersRenderTarget.texture[0];\n      this.depthTexture = this.gBuffersRenderTarget.texture[1];\n    } else {\n      // depth pass\n      this.webgl1DepthPass = new DepthPass(this._scene, this._camera);\n      this.webgl1DepthPass.renderTarget.minFilter = LinearFilter;\n      this.webgl1DepthPass.renderTarget.magFilter = LinearFilter;\n      this.webgl1DepthPass.renderTarget.texture.minFilter = LinearFilter;\n      this.webgl1DepthPass.renderTarget.texture.magFilter = LinearFilter;\n      this.webgl1DepthPass.setSize(typeof window !== \"undefined\" ? window.innerWidth : 2000, typeof window !== \"undefined\" ? window.innerHeight : 1000); // render normals (in the rgb channel) and roughness (in the alpha channel) in gBuffersRenderTarget\n\n      this.gBuffersRenderTarget = new WebGLRenderTarget(width, height, {\n        minFilter: LinearFilter,\n        magFilter: LinearFilter\n      });\n      this.normalTexture = this.gBuffersRenderTarget.texture;\n      this.depthTexture = this.webgl1DepthPass.texture;\n    } // set up uniforms\n\n    this.fullscreenMaterial.uniforms.normalTexture.value = this.normalTexture;\n    this.fullscreenMaterial.uniforms.depthTexture.value = this.depthTexture;\n    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssrEffect.temporalResolvePass.accumulatedTexture;\n    this.fullscreenMaterial.uniforms.cameraMatrixWorld.value = this._camera.matrixWorld;\n    this.fullscreenMaterial.uniforms._projectionMatrix.value = this._camera.projectionMatrix;\n    this.fullscreenMaterial.uniforms._inverseProjectionMatrix.value = this._camera.projectionMatrixInverse;\n  }\n  setSize(width, height) {\n    this.renderTarget.setSize(width * this.ssrEffect.resolutionScale, height * this.ssrEffect.resolutionScale);\n    this.gBuffersRenderTarget.setSize(width * this.ssrEffect.resolutionScale, height * this.ssrEffect.resolutionScale);\n    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssrEffect.temporalResolvePass.accumulatedTexture;\n    this.fullscreenMaterial.needsUpdate = true;\n  }\n  dispose() {\n    this.renderTarget.dispose();\n    this.gBuffersRenderTarget.dispose();\n    this.renderPass.dispose();\n    if (!this.USE_MRT) this.webgl1DepthPass.dispose();\n    this.fullscreenMaterial.dispose();\n    this.normalTexture = null;\n    this.depthTexture = null;\n    this.velocityTexture = null;\n  }\n  keepMaterialMapUpdated(mrtMaterial, originalMaterial, prop, define) {\n    if (this.ssrEffect[define]) {\n      if (originalMaterial[prop] !== mrtMaterial[prop]) {\n        mrtMaterial[prop] = originalMaterial[prop];\n        mrtMaterial.uniforms[prop].value = originalMaterial[prop];\n        if (originalMaterial[prop]) {\n          mrtMaterial.defines[define] = \"\";\n        } else {\n          delete mrtMaterial.defines[define];\n        }\n        mrtMaterial.needsUpdate = true;\n      }\n    } else if (mrtMaterial[prop] !== undefined) {\n      mrtMaterial[prop] = undefined;\n      mrtMaterial.uniforms[prop].value = undefined;\n      delete mrtMaterial.defines[define];\n      mrtMaterial.needsUpdate = true;\n    }\n  }\n  setMRTMaterialInScene() {\n    this.visibleMeshes = getVisibleChildren(this._scene);\n    for (const c of this.visibleMeshes) {\n      if (c.material) {\n        const originalMaterial = c.material;\n        let [cachedOriginalMaterial, mrtMaterial] = this.cachedMaterials.get(c) || [];\n        if (originalMaterial !== cachedOriginalMaterial) {\n          if (mrtMaterial) mrtMaterial.dispose();\n          mrtMaterial = new MRTMaterial();\n          if (this.USE_MRT) mrtMaterial.defines.USE_MRT = \"\";\n          mrtMaterial.normalScale = originalMaterial.normalScale;\n          mrtMaterial.uniforms.normalScale.value = originalMaterial.normalScale;\n          const map = originalMaterial.map || originalMaterial.normalMap || originalMaterial.roughnessMap || originalMaterial.metalnessMap;\n          if (map) mrtMaterial.uniforms.uvTransform.value = map.matrix;\n          this.cachedMaterials.set(c, [originalMaterial, mrtMaterial]);\n        } // update the child's MRT material\n\n        this.keepMaterialMapUpdated(mrtMaterial, originalMaterial, \"normalMap\", \"useNormalMap\");\n        this.keepMaterialMapUpdated(mrtMaterial, originalMaterial, \"roughnessMap\", \"useRoughnessMap\");\n        mrtMaterial.uniforms.roughness.value = this.ssrEffect.selection.size === 0 || this.ssrEffect.selection.has(c) ? originalMaterial.roughness || 0 : 10e10;\n        c.material = mrtMaterial;\n      }\n    }\n  }\n  unsetMRTMaterialInScene() {\n    for (const c of this.visibleMeshes) {\n      var _c$material;\n      if (((_c$material = c.material) == null ? void 0 : _c$material.type) === \"MRTMaterial\") {\n        c.visible = true; // set material back to the original one\n\n        const [originalMaterial] = this.cachedMaterials.get(c);\n        c.material = originalMaterial;\n      }\n    }\n  }\n  render(renderer, inputBuffer) {\n    this.setMRTMaterialInScene();\n    renderer.setRenderTarget(this.gBuffersRenderTarget);\n    this.renderPass.render(renderer, this.gBuffersRenderTarget);\n    this.unsetMRTMaterialInScene(); // render depth and velocity in seperate passes\n\n    if (!this.USE_MRT) this.webgl1DepthPass.renderPass.render(renderer, this.webgl1DepthPass.renderTarget);\n    this.fullscreenMaterial.uniforms.inputTexture.value = inputBuffer.texture;\n    this.fullscreenMaterial.uniforms.samples.value = this.ssrEffect.temporalResolvePass.samples;\n    this.fullscreenMaterial.uniforms.cameraNear.value = this._camera.near;\n    this.fullscreenMaterial.uniforms.cameraFar.value = this._camera.far;\n    this.fullscreenMaterial.uniforms.viewMatrix.value.copy(this._camera.matrixWorldInverse);\n    renderer.setRenderTarget(this.renderTarget);\n    renderer.render(this.scene, this.camera);\n  }\n}\n\n/**\n* Options of the SSR effect\n* @typedef {Object} SSROptions\n* @property {Number} [intensity] intensity of the reflections\n* @property {Number} [exponent] exponent by which reflections will be potentiated when composing the current frame's reflections and the accumulated reflections into a final reflection; higher values will make reflections clearer by highlighting darker spots less\n* @property {Number} [distance] maximum distance a reflection ray can travel to find what it reflects\n* @property {Number} [fade] how much reflections will fade out by distance\n* @property {Number} [roughnessFade] how intense reflections should be on rough spots; a higher value will make reflections fade out quicker on rough spots\n* @property {Number} [thickness] maximum depth difference between a ray and the particular depth at its screen position before refining with binary search; higher values will result in better performance\n* @property {Number} [ior] Index of Refraction, used for calculating fresnel; reflections tend to be more intense the steeper the angle between them and the viewer is, the ior parameter sets how much the intensity varies\n* @property {Number} [maxRoughness] maximum roughness a texel can have to have reflections calculated for it\n* @property {Number} [maxDepthDifference] maximum depth difference between a ray and the particular depth at its screen position after refining with binary search; higher values will result in better performance\n* @property {Number} [blend] a value between 0 and 1 to set how much the last frame's reflections should be blended in; higher values will result in less noisy reflections when moving the camera but a more smeary look\n* @property {boolean} [correction] how much pixels should be corrected when doing temporal resolving; higher values will result in less smearing but more noise\n* @property {boolean} [correctionRadius] how many surrounding pixels will be used for neighborhood clamping; a higher value can reduce noise when moving the camera but will result in less performance\n* @property {Number} [blur] how much the blurred reflections should be mixed with the raw reflections\n* @property {Number} [blurKernel] kernel size of the Box Blur Filter; higher kernel sizes will result in blurrier reflections with more artifacts\n* @property {Number} [blurSharpness] exponent of the Box Blur filter; higher values will result in more sharpness\n* @property {Number} [jitter] how intense jittering should be\n* @property {Number} [jitterRoughness] how intense jittering should be in relation to a material's roughness\n* @property {Number} [steps] number of steps a reflection ray can maximally do to find an object it intersected (and thus reflects)\n* @property {Number} [refineSteps] once we had our ray intersect something, we need to find the exact point in space it intersected and thus it reflects; this can be done through binary search with the given number of maximum steps\n* @property {boolean} [missedRays] if there should still be reflections for rays for which a reflecting point couldn't be found; enabling this will result in stretched looking reflections which can look good or bad depending on the angle\n* @property {boolean} [useNormalMap] if roughness maps should be taken account of when calculating reflections\n* @property {boolean} [useRoughnessMap] if normal maps should be taken account of when calculating reflections\n* @property {Number} [resolutionScale] resolution of the SSR effect, a resolution of 0.5 means the effect will be rendered at half resolution\n* @property {Number} [velocityResolutionScale] resolution of the velocity buffer, a resolution of 0.5 means velocity will be rendered at half resolution\n*/\n\n/**\n * The options of the SSR effect\n * @type {SSROptions}\n */\nconst defaultSSROptions = {\n  intensity: 1,\n  exponent: 1,\n  distance: 10,\n  fade: 0,\n  roughnessFade: 1,\n  thickness: 10,\n  ior: 1.45,\n  maxRoughness: 1,\n  maxDepthDifference: 10,\n  blend: 0.9,\n  correction: 1,\n  correctionRadius: 1,\n  blur: 0.5,\n  blurKernel: 1,\n  blurSharpness: 10,\n  jitter: 0,\n  jitterRoughness: 0,\n  steps: 20,\n  refineSteps: 5,\n  missedRays: true,\n  useNormalMap: true,\n  useRoughnessMap: true,\n  resolutionScale: 1,\n  velocityResolutionScale: 1\n};\nvar vertexShader = \"#define GLSLIFY 1\\nvarying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}\"; // eslint-disable-line\n\nvar temporalResolve = \"#define GLSLIFY 1\\nuniform sampler2D inputTexture;uniform sampler2D accumulatedTexture;uniform sampler2D velocityTexture;uniform sampler2D lastVelocityTexture;uniform float blend;uniform float correction;uniform float exponent;uniform float samples;uniform vec2 invTexSize;uniform mat4 curInverseProjectionMatrix;uniform mat4 curCameraMatrixWorld;uniform mat4 prevInverseProjectionMatrix;uniform mat4 prevCameraMatrixWorld;varying vec2 vUv;\\n#define MAX_NEIGHBOR_DEPTH_DIFFERENCE 0.001\\n#define FLOAT_EPSILON 0.00001\\n#define FLOAT_ONE_MINUS_EPSILON 0.99999\\nvec3 transformexponent;vec3 undoColorTransformExponent;vec3 transformColor(vec3 color){if(exponent==1.0)return color;return pow(abs(color),transformexponent);}vec3 undoColorTransform(vec3 color){if(exponent==1.0)return color;return max(pow(abs(color),undoColorTransformExponent),vec3(0.0));}void main(){if(exponent!=1.0){transformexponent=vec3(1.0/exponent);undoColorTransformExponent=vec3(exponent);}vec4 inputTexel=textureLod(inputTexture,vUv,0.0);vec4 accumulatedTexel;vec3 inputColor=transformColor(inputTexel.rgb);vec3 accumulatedColor;float alpha=inputTexel.a;float velocityDisocclusion;bool didReproject=false;\\n#ifdef boxBlur\\nvec3 boxBlurredColor=inputTexel.rgb;\\n#endif\\nvec4 velocity=textureLod(velocityTexture,vUv,0.0);bool isMoving=alpha<1.0||dot(velocity.xy,velocity.xy)>0.0;if(isMoving){vec3 minNeighborColor=inputColor;vec3 maxNeighborColor=inputColor;vec3 col;vec2 neighborUv;vec2 reprojectedUv=vUv-velocity.xy;vec4 lastVelocity=textureLod(lastVelocityTexture,reprojectedUv,0.0);float depth=velocity.b;float closestDepth=depth;float lastClosestDepth=lastVelocity.b;float neighborDepth;float lastNeighborDepth;for(int x=-correctionRadius;x<=correctionRadius;x++){for(int y=-correctionRadius;y<=correctionRadius;y++){if(x!=0||y!=0){neighborUv=vUv+vec2(x,y)*invTexSize;vec4 neigborVelocity=textureLod(velocityTexture,neighborUv,0.0);neighborDepth=neigborVelocity.b;col=textureLod(inputTexture,neighborUv,0.0).xyz;int absX=abs(x);int absY=abs(y);\\n#ifdef dilation\\nif(absX==1&&absY==1){if(neighborDepth>closestDepth){velocity=neigborVelocity;closestDepth=neighborDepth;}vec4 lastNeighborVelocity=textureLod(velocityTexture,vUv+vec2(x,y)*invTexSize,0.0);lastNeighborDepth=lastNeighborVelocity.b;if(neighborDepth>closestDepth){lastVelocity=lastNeighborVelocity;lastClosestDepth=lastNeighborDepth;}}\\n#endif\\nif(abs(depth-neighborDepth)<MAX_NEIGHBOR_DEPTH_DIFFERENCE){\\n#ifdef boxBlur\\nif(absX<=2&&absY<=2)boxBlurredColor+=col;\\n#endif\\ncol=transformColor(col);minNeighborColor=min(col,minNeighborColor);maxNeighborColor=max(col,maxNeighborColor);}}}}float velocityLength=length(lastVelocity.xy-velocity.xy);velocityDisocclusion=(velocityLength-0.000005)*10.0;velocityDisocclusion*=velocityDisocclusion;reprojectedUv=vUv-velocity.xy;\\n#ifdef boxBlur\\nfloat pxRadius=correctionRadius>5 ? 121.0 : pow(float(correctionRadius*2+1),2.0);boxBlurredColor/=pxRadius;boxBlurredColor=transformColor(boxBlurredColor);\\n#endif\\nif(reprojectedUv.x>=0.0&&reprojectedUv.x<=1.0&&reprojectedUv.y>=0.0&&reprojectedUv.y<=1.0){accumulatedTexel=textureLod(accumulatedTexture,reprojectedUv,0.0);accumulatedColor=transformColor(accumulatedTexel.rgb);vec3 clampedColor=clamp(accumulatedColor,minNeighborColor,maxNeighborColor);accumulatedColor=mix(accumulatedColor,clampedColor,correction);didReproject=true;}else{\\n#ifdef boxBlur\\naccumulatedColor=boxBlurredColor;\\n#else\\naccumulatedColor=inputColor;\\n#endif\\n}if(velocity.r>FLOAT_ONE_MINUS_EPSILON&&velocity.g>FLOAT_ONE_MINUS_EPSILON){alpha=0.0;velocityDisocclusion=1.0;}}else{accumulatedColor=transformColor(textureLod(accumulatedTexture,vUv,0.0).rgb);}vec3 outputColor=inputColor;\\n#include <custom_compose_shader>\\ngl_FragColor=vec4(undoColorTransform(outputColor),alpha);}\"; // eslint-disable-line\n\nclass TemporalResolveMaterial extends ShaderMaterial {\n  constructor(customComposeShader) {\n    const fragmentShader = temporalResolve.replace(\"#include <custom_compose_shader>\", customComposeShader);\n    super({\n      type: \"TemporalResolveMaterial\",\n      uniforms: {\n        inputTexture: new Uniform(null),\n        accumulatedTexture: new Uniform(null),\n        velocityTexture: new Uniform(null),\n        lastVelocityTexture: new Uniform(null),\n        samples: new Uniform(1),\n        blend: new Uniform(0.5),\n        correction: new Uniform(1),\n        exponent: new Uniform(1),\n        invTexSize: new Uniform(new Vector2())\n      },\n      defines: {\n        correctionRadius: 1\n      },\n      vertexShader,\n      fragmentShader\n    });\n  }\n}\n\n// this shader is from: https://github.com/gkjohnson/threejs-sandbox\n// a second set of bone information from the previou frame\n\nconst prev_skinning_pars_vertex = /* glsl */\n`\n\t\t#ifdef USE_SKINNING\n\t\t#ifdef BONE_TEXTURE\n\t\t\tuniform sampler2D prevBoneTexture;\n\t\t\tmat4 getPrevBoneMatrix( const in float i ) {\n\t\t\t\tfloat j = i * 4.0;\n\t\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\t\ty = dy * ( y + 0.5 );\n\t\t\t\tvec4 v1 = texture2D( prevBoneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\t\tvec4 v2 = texture2D( prevBoneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\t\tvec4 v3 = texture2D( prevBoneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\t\tvec4 v4 = texture2D( prevBoneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\t\treturn bone;\n\t\t\t}\n\t\t#else\n\t\t\tuniform mat4 prevBoneMatrices[ MAX_BONES ];\n\t\t\tmat4 getPrevBoneMatrix( const in float i ) {\n\t\t\t\tmat4 bone = prevBoneMatrices[ int(i) ];\n\t\t\t\treturn bone;\n\t\t\t}\n\t\t#endif\n\t\t#endif\n`; // Returns the body of the vertex shader for the velocity buffer and\n// outputs the position of the current and last frame positions\n\nconst velocity_vertex = /* glsl */\n`\n\t\tvec3 transformed;\n\n\t\t// Get the normal\n\t\t${ShaderChunk.skinbase_vertex}\n\t\t${ShaderChunk.beginnormal_vertex}\n\t\t${ShaderChunk.skinnormal_vertex}\n\t\t${ShaderChunk.defaultnormal_vertex}\n\n\t\t// Get the current vertex position\n\t\ttransformed = vec3( position );\n\t\t${ShaderChunk.skinning_vertex}\n\t\tnewPosition = velocityMatrix * vec4( transformed, 1.0 );\n\n\t\t// Get the previous vertex position\n\t\ttransformed = vec3( position );\n\t\t${ShaderChunk.skinbase_vertex.replace(/mat4 /g, \"\").replace(/getBoneMatrix/g, \"getPrevBoneMatrix\")}\n\t\t${ShaderChunk.skinning_vertex.replace(/vec4 /g, \"\")}\n\t\tprevPosition = prevVelocityMatrix * vec4( transformed, 1.0 );\n\n\t\tgl_Position = newPosition;\n`;\nclass VelocityMaterial extends ShaderMaterial {\n  constructor() {\n    super({\n      uniforms: {\n        prevVelocityMatrix: {\n          value: new Matrix4()\n        },\n        velocityMatrix: {\n          value: new Matrix4()\n        },\n        prevBoneTexture: {\n          value: null\n        },\n        interpolateGeometry: {\n          value: 0\n        },\n        intensity: {\n          value: 1\n        },\n        boneTexture: {\n          value: null\n        },\n        alphaTest: {\n          value: 0.0\n        },\n        map: {\n          value: null\n        },\n        alphaMap: {\n          value: null\n        },\n        opacity: {\n          value: 1.0\n        }\n      },\n      vertexShader: /* glsl */\n      `\n                    #define MAX_BONES 1024\n                    \n                    ${ShaderChunk.skinning_pars_vertex}\n                    ${prev_skinning_pars_vertex}\n        \n                    uniform mat4 velocityMatrix;\n                    uniform mat4 prevVelocityMatrix;\n                    uniform float interpolateGeometry;\n                    varying vec4 prevPosition;\n                    varying vec4 newPosition;\n\t\t\t\t\tvarying vec2 vHighPrecisionZW;\n        \n                    void main() {\n        \n                        ${velocity_vertex}\n\n\t\t\t\t\t\tvHighPrecisionZW = gl_Position.zw;\n        \n                    }`,\n      fragmentShader: /* glsl */\n      `\n                    uniform float intensity;\n                    varying vec4 prevPosition;\n                    varying vec4 newPosition;\n\t\t\t\t\tvarying vec2 vHighPrecisionZW;\n        \n                    void main() {\n\t\t\t\t\t\t#ifdef FULL_MOVEMENT\n\t\t\t\t\t\tgl_FragColor = vec4( 1., 1., 1. - gl_FragCoord.z, 0. );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t\t#endif\n\n                        vec2 pos0 = (prevPosition.xy / prevPosition.w) * 0.5 + 0.5;\n                        vec2 pos1 = (newPosition.xy / newPosition.w) * 0.5 + 0.5;\n        \n                        vec2 vel = pos1 - pos0;\n\n\t\t\t\t\t\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n                        \n                        gl_FragColor = vec4( vel, 1. - fragCoordZ, 0. );\n        \n                    }`\n    });\n    this.isVelocityMaterial = true;\n  }\n}\nconst backgroundColor = new Color(0);\nconst updateProperties = [\"visible\", \"wireframe\", \"side\"];\nclass VelocityPass extends Pass {\n  constructor(scene, camera) {\n    var _window, _window2;\n    super(\"VelocityPass\");\n    this.cachedMaterials = new WeakMap();\n    this.lastCameraTransform = {\n      position: new Vector3(),\n      quaternion: new Quaternion()\n    };\n    this.visibleMeshes = [];\n    this.renderedMeshesThisFrame = 0;\n    this.renderedMeshesLastFrame = 0;\n    this._scene = scene;\n    this._camera = camera;\n    this.renderTarget = new WebGLRenderTarget(((_window = window) == null ? void 0 : _window.innerWidth) || 1000, ((_window2 = window) == null ? void 0 : _window2.innerHeight) || 1000, {\n      type: HalfFloatType\n    });\n  }\n  setVelocityMaterialInScene() {\n    this.renderedMeshesThisFrame = 0;\n    this.visibleMeshes = getVisibleChildren(this._scene);\n    for (const c of this.visibleMeshes) {\n      var _c$skeleton2;\n      const originalMaterial = c.material;\n      let [cachedOriginalMaterial, velocityMaterial] = this.cachedMaterials.get(c) || [];\n      if (originalMaterial !== cachedOriginalMaterial) {\n        var _c$skeleton;\n        velocityMaterial = new VelocityMaterial();\n        velocityMaterial.lastMatrixWorld = new Matrix4();\n        c.material = velocityMaterial;\n        if ((_c$skeleton = c.skeleton) != null && _c$skeleton.boneTexture) this.saveBoneTexture(c);\n        this.cachedMaterials.set(c, [originalMaterial, velocityMaterial]);\n      }\n      velocityMaterial.uniforms.velocityMatrix.value.multiplyMatrices(this._camera.projectionMatrix, c.modelViewMatrix);\n      if (c.userData.needsUpdatedReflections || originalMaterial.map instanceof VideoTexture) {\n        if (!(\"FULL_MOVEMENT\" in velocityMaterial.defines)) velocityMaterial.needsUpdate = true;\n        velocityMaterial.defines.FULL_MOVEMENT = \"\";\n      } else {\n        if (\"FULL_MOVEMENT\" in velocityMaterial.defines) {\n          delete velocityMaterial.defines.FULL_MOVEMENT;\n          velocityMaterial.needsUpdate = true;\n        }\n      }\n      c.visible = this.cameraMovedThisFrame || !c.matrixWorld.equals(velocityMaterial.lastMatrixWorld) || c.skeleton || \"FULL_MOVEMENT\" in velocityMaterial.defines;\n      c.material = velocityMaterial;\n      if (!c.visible) continue;\n      this.renderedMeshesThisFrame++;\n      for (const prop of updateProperties) velocityMaterial[prop] = originalMaterial[prop];\n      if ((_c$skeleton2 = c.skeleton) != null && _c$skeleton2.boneTexture) {\n        velocityMaterial.defines.USE_SKINNING = \"\";\n        velocityMaterial.defines.BONE_TEXTURE = \"\";\n        velocityMaterial.uniforms.boneTexture.value = c.skeleton.boneTexture;\n      }\n    }\n  }\n  saveBoneTexture(object) {\n    let boneTexture = object.material.uniforms.prevBoneTexture.value;\n    if (boneTexture && boneTexture.image.width === object.skeleton.boneTexture.width) {\n      boneTexture = object.material.uniforms.prevBoneTexture.value;\n      boneTexture.image.data.set(object.skeleton.boneTexture.image.data);\n    } else {\n      var _boneTexture;\n      (_boneTexture = boneTexture) == null ? void 0 : _boneTexture.dispose();\n      const boneMatrices = object.skeleton.boneTexture.image.data.slice();\n      const size = object.skeleton.boneTexture.image.width;\n      boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);\n      object.material.uniforms.prevBoneTexture.value = boneTexture;\n      boneTexture.needsUpdate = true;\n    }\n  }\n  unsetVelocityMaterialInScene() {\n    for (const c of this.visibleMeshes) {\n      if (c.material.isVelocityMaterial) {\n        var _c$skeleton3;\n        c.visible = true;\n        c.material.lastMatrixWorld.copy(c.matrixWorld);\n        c.material.uniforms.prevVelocityMatrix.value.multiplyMatrices(this._camera.projectionMatrix, c.modelViewMatrix);\n        if ((_c$skeleton3 = c.skeleton) != null && _c$skeleton3.boneTexture) this.saveBoneTexture(c);\n        c.material = this.cachedMaterials.get(c)[0];\n      }\n    }\n  }\n  setSize(width, height) {\n    this.renderTarget.setSize(width, height);\n  }\n  renderVelocity(renderer) {\n    renderer.setRenderTarget(this.renderTarget);\n    if (this.renderedMeshesThisFrame > 0) {\n      const {\n        background\n      } = this._scene;\n      this._scene.background = backgroundColor;\n      renderer.render(this._scene, this._camera);\n      this._scene.background = background;\n    } else {\n      renderer.clearColor();\n    }\n  }\n  checkCameraMoved() {\n    const moveDist = this.lastCameraTransform.position.distanceToSquared(this._camera.position);\n    const rotateDist = 8 * (1 - this.lastCameraTransform.quaternion.dot(this._camera.quaternion));\n    if (moveDist > 0.000001 || rotateDist > 0.000001) {\n      this.lastCameraTransform.position.copy(this._camera.position);\n      this.lastCameraTransform.quaternion.copy(this._camera.quaternion);\n      return true;\n    }\n    return false;\n  }\n  render(renderer) {\n    this.cameraMovedThisFrame = this.checkCameraMoved();\n    this.setVelocityMaterialInScene();\n    if (this.renderedMeshesThisFrame > 0 || this.renderedMeshesLastFrame > 0) this.renderVelocity(renderer);\n    this.unsetVelocityMaterialInScene();\n    this.renderedMeshesLastFrame = this.renderedMeshesThisFrame;\n  }\n}\nconst zeroVec2 = new Vector2(); // the following variables can be accessed by the custom compose shader:\n// \"inputTexel\", \"accumulatedTexel\", \"inputColor\", \"accumulatedColor\", \"alpha\", \"velocityDisocclusion\", \"didReproject\", \"boxBlurredColor\" (if using box blur)\n// the custom compose shader will write the final color to the variable \"outputColor\"\n\nclass TemporalResolvePass extends Pass {\n  constructor(scene, camera, customComposeShader) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    super(\"TemporalResolvePass\");\n    this.velocityPass = null;\n    this.velocityResolutionScale = 1;\n    this.samples = 1;\n    this.lastCameraTransform = {\n      position: new Vector3(),\n      quaternion: new Quaternion()\n    };\n    this._scene = scene;\n    this._camera = camera;\n    this.renderTarget = new WebGLRenderTarget(1, 1, {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      type: HalfFloatType,\n      depthBuffer: false\n    });\n    this.velocityPass = new VelocityPass(scene, camera);\n    this.fullscreenMaterial = new TemporalResolveMaterial(customComposeShader);\n    this.fullscreenMaterial.defines.correctionRadius = options.correctionRadius || 1;\n    if (options.dilation) this.fullscreenMaterial.defines.dilation = \"\";\n    if (options.boxBlur) this.fullscreenMaterial.defines.boxBlur = \"\";\n    this.setupFramebuffers(1, 1);\n    this.checkCanUseSharedVelocityTexture();\n  }\n  dispose() {\n    if (this._scene.userData.velocityTexture === this.velocityPass.renderTarget.texture) {\n      delete this._scene.userData.velocityTexture;\n      delete this._scene.userData.lastVelocityTexture;\n    }\n    this.renderTarget.dispose();\n    this.accumulatedTexture.dispose();\n    this.fullscreenMaterial.dispose();\n    this.velocityPass.dispose();\n  }\n  setSize(width, height) {\n    this.renderTarget.setSize(width, height);\n    this.velocityPass.setSize(width * this.velocityResolutionScale, height * this.velocityResolutionScale);\n    this.velocityPass.renderTarget.texture.minFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;\n    this.velocityPass.renderTarget.texture.magFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;\n    this.velocityPass.renderTarget.texture.needsUpdate = true;\n    this.fullscreenMaterial.uniforms.invTexSize.value.set(1 / width, 1 / height);\n    this.setupFramebuffers(width, height);\n  }\n  setupFramebuffers(width, height) {\n    if (this.accumulatedTexture) this.accumulatedTexture.dispose();\n    if (this.lastVelocityTexture) this.lastVelocityTexture.dispose();\n    this.accumulatedTexture = new FramebufferTexture(width, height, RGBAFormat);\n    this.accumulatedTexture.minFilter = LinearFilter;\n    this.accumulatedTexture.magFilter = LinearFilter;\n    this.accumulatedTexture.type = HalfFloatType;\n    this.lastVelocityTexture = new FramebufferTexture(width * this.velocityResolutionScale, height * this.velocityResolutionScale, RGBAFormat);\n    this.lastVelocityTexture.minFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;\n    this.lastVelocityTexture.magFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;\n    this.lastVelocityTexture.type = HalfFloatType;\n    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.accumulatedTexture;\n    this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this.lastVelocityTexture;\n    this.fullscreenMaterial.needsUpdate = true;\n  }\n  checkCanUseSharedVelocityTexture() {\n    const canUseSharedVelocityTexture = this._scene.userData.velocityTexture && this.velocityPass.renderTarget.texture !== this._scene.userData.velocityTexture;\n    if (canUseSharedVelocityTexture) {\n      // let's use the shared one instead\n      if (this.velocityPass.renderTarget.texture === this.fullscreenMaterial.uniforms.velocityTexture.value) {\n        this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this._scene.userData.lastVelocityTexture;\n        this.fullscreenMaterial.uniforms.velocityTexture.value = this._scene.userData.velocityTexture;\n        this.fullscreenMaterial.needsUpdate = true;\n      }\n    } else {\n      // let's stop using the shared one (if used) and mark ours as the shared one instead\n      if (this.velocityPass.renderTarget.texture !== this.fullscreenMaterial.uniforms.velocityTexture.value) {\n        this.fullscreenMaterial.uniforms.velocityTexture.value = this.velocityPass.renderTarget.texture;\n        this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this.lastVelocityTexture;\n        this.fullscreenMaterial.needsUpdate = true;\n        if (!this._scene.userData.velocityTexture) {\n          this._scene.userData.velocityTexture = this.velocityPass.renderTarget.texture;\n          this._scene.userData.lastVelocityTexture = this.lastVelocityTexture;\n        }\n      }\n    }\n    return this.velocityPass.renderTarget.texture !== this.fullscreenMaterial.uniforms.velocityTexture.value;\n  }\n  checkNeedsResample() {\n    const moveDist = this.lastCameraTransform.position.distanceToSquared(this._camera.position);\n    const rotateDist = 8 * (1 - this.lastCameraTransform.quaternion.dot(this._camera.quaternion));\n    if (moveDist > 0.000001 || rotateDist > 0.000001) {\n      this.samples = 1;\n      this.lastCameraTransform.position.copy(this._camera.position);\n      this.lastCameraTransform.quaternion.copy(this._camera.quaternion);\n    }\n  }\n  render(renderer) {\n    this.samples++;\n    this.checkNeedsResample();\n    this.fullscreenMaterial.uniforms.samples.value = this.samples; // const isUsingSharedVelocityTexture = this.checkCanUseSharedVelocityTexture()\n    // if (!isUsingSharedVelocityTexture) this.velocityPass.render(renderer)\n\n    renderer.setRenderTarget(this.renderTarget);\n    renderer.render(this.scene, this.camera); // save the render target's texture for use in next frame\n\n    renderer.copyFramebufferToTexture(zeroVec2, this.accumulatedTexture);\n    renderer.setRenderTarget(this.velocityPass.renderTarget);\n    renderer.copyFramebufferToTexture(zeroVec2, this.lastVelocityTexture);\n  }\n}\n\n// source: https://observablehq.com/@jrus/halton\nconst halton = function halton(index, base) {\n  let fraction = 1;\n  let result = 0;\n  while (index > 0) {\n    fraction /= base;\n    result += fraction * (index % base);\n    index = ~~(index / base); // floor division\n  }\n\n  return result;\n}; // generates Halton tuples in the range [-0.5:0.5]\n\nconst generateHalton23Points = count => {\n  const data = [];\n  let i = 1;\n  const end = i + count;\n  for (; i < end; i++) {\n    data.push([halton(i, 2) - 0.5, halton(i, 3) - 0.5]);\n  }\n  return data;\n};\n\n/* eslint-disable camelcase */\n\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n} // credits for the box-projecting shader code go to codercat (https://codercat.tk)\n\nconst worldposReplace = /* glsl */\n`\n#if defined( USE_ENVMAP ) || defined(  ) || defined ( USE_SHADOWMAP )\n    vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n    #ifdef BOX_PROJECTED_ENV_MAP\n        vWorldPosition = worldPosition.xyz;\n    #endif\n#endif\n`;\nconst boxProjectDefinitions = /* glsl */\n`\n#ifdef BOX_PROJECTED_ENV_MAP\n    uniform vec3 envMapSize;\n    uniform vec3 envMapPosition;\n    varying vec3 vWorldPosition;\n    \n    vec3 parallaxCorrectNormal( vec3 v, vec3 cubeSize, vec3 cubePos ) {\n        vec3 nDir = normalize( v );\n\n        vec3 rbmax = ( .5 * cubeSize + cubePos - vWorldPosition ) / nDir;\n        vec3 rbmin = ( -.5 * cubeSize + cubePos - vWorldPosition ) / nDir;\n\n        vec3 rbminmax;\n\n        rbminmax.x = ( nDir.x > 0. ) ? rbmax.x : rbmin.x;\n        rbminmax.y = ( nDir.y > 0. ) ? rbmax.y : rbmin.y;\n        rbminmax.z = ( nDir.z > 0. ) ? rbmax.z : rbmin.z;\n\n        float correction = min( min( rbminmax.x, rbminmax.y ), rbminmax.z );\n        vec3 boxIntersection = vWorldPosition + nDir * correction;\n        \n        return boxIntersection - cubePos;\n    }\n#endif\n`; // will be inserted after \"vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\"\n\nconst getIBLIrradiance_patch = /* glsl */\n`\n#ifdef BOX_PROJECTED_ENV_MAP\n    worldNormal = parallaxCorrectNormal( worldNormal, envMapSize, envMapPosition );\n#endif\n`; // will be inserted after \"reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\"\n\nconst getIBLRadiance_patch = /* glsl */\n`\n#ifdef BOX_PROJECTED_ENV_MAP\n    reflectVec = parallaxCorrectNormal( reflectVec, envMapSize, envMapPosition );\n#endif\n`;\nfunction useBoxProjectedEnvMap(shader, envMapPosition, envMapSize) {\n  // defines\n  shader.defines.BOX_PROJECTED_ENV_MAP = \"\"; // uniforms\n\n  shader.uniforms.envMapPosition = {\n    value: envMapPosition\n  };\n  shader.uniforms.envMapSize = {\n    value: envMapSize\n  };\n  const line1 = new RegExp(escapeRegExp(\"vec3 worldNormal = inverseTransformDirection ( normal , viewMatrix ) ;\").replaceAll(\" \", \"\\\\s*\"), \"g\");\n  const line2 = new RegExp(escapeRegExp(\"reflectVec = inverseTransformDirection ( reflectVec , viewMatrix ) ;\").replaceAll(\" \", \"\\\\s*\"), \"g\"); // vertex shader\n\n  shader.vertexShader = \"varying vec3 vWorldPosition;\\n\" + shader.vertexShader.replace(\"#include <worldpos_vertex>\", worldposReplace); // fragment shader\n\n  shader.fragmentShader = boxProjectDefinitions + \"\\n\" + shader.fragmentShader.replace(\"#include <envmap_physical_pars_fragment>\", ShaderChunk.envmap_physical_pars_fragment).replace(line1, `vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n                ${getIBLIrradiance_patch}`).replace(line2, `reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n                ${getIBLRadiance_patch}`);\n}\nconst finalFragmentShader = finalSSRShader.replace(\"#include <helperFunctions>\", helperFunctions).replace(\"#include <boxBlur>\", boxBlur); // all the properties for which we don't have to resample\n\nconst noResetSamplesProperties = [\"blur\", \"blurSharpness\", \"blurKernel\"];\nconst defaultCubeRenderTarget = new WebGLCubeRenderTarget(1);\nlet pmremGenerator;\nclass SSREffect extends Effect {\n  /**\n   * @param {THREE.Scene} scene The scene of the SSR effect\n   * @param {THREE.Camera} camera The camera with which SSR is being rendered\n   * @param {SSROptions} [options] The optional options for the SSR effect\n   */\n  constructor(scene, camera) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultSSROptions;\n    super(\"SSREffect\", finalFragmentShader, {\n      type: \"FinalSSRMaterial\",\n      uniforms: new Map([[\"reflectionsTexture\", new Uniform(null)], [\"blur\", new Uniform(0)], [\"blurSharpness\", new Uniform(0)], [\"blurKernel\", new Uniform(0)]]),\n      defines: new Map([[\"RENDER_MODE\", \"0\"]])\n    });\n    this.haltonSequence = generateHalton23Points(1024);\n    this.haltonIndex = 0;\n    this.selection = new Selection();\n    this.lastSize = void 0;\n    this.cubeCamera = new CubeCamera(0.001, 1000, defaultCubeRenderTarget);\n    this.usingBoxProjectedEnvMap = false;\n    this._scene = scene;\n    this._camera = camera;\n    const trOptions = {\n      boxBlur: true,\n      dilation: true\n    };\n    options = _extends({}, defaultSSROptions, options, trOptions); // set up passes\n    // temporal resolve pass\n\n    this.temporalResolvePass = new TemporalResolvePass(scene, camera, trCompose, options);\n    this.uniforms.get(\"reflectionsTexture\").value = this.temporalResolvePass.renderTarget.texture; // reflections pass\n\n    this.reflectionsPass = new ReflectionsPass(this, options);\n    this.temporalResolvePass.fullscreenMaterial.uniforms.inputTexture.value = this.reflectionsPass.renderTarget.texture;\n    this.lastSize = {\n      width: options.width,\n      height: options.height,\n      resolutionScale: options.resolutionScale,\n      velocityResolutionScale: options.velocityResolutionScale\n    };\n    this.setSize(options.width, options.height);\n    this.makeOptionsReactive(options);\n  }\n  makeOptionsReactive(options) {\n    let needsUpdate = false;\n    const reflectionPassFullscreenMaterialUniforms = this.reflectionsPass.fullscreenMaterial.uniforms;\n    const reflectionPassFullscreenMaterialUniformsKeys = Object.keys(reflectionPassFullscreenMaterialUniforms);\n    for (const key of Object.keys(options)) {\n      Object.defineProperty(this, key, {\n        get() {\n          return options[key];\n        },\n        set(value) {\n          if (options[key] === value && needsUpdate) return;\n          options[key] = value;\n          if (!noResetSamplesProperties.includes(key)) {\n            this.setSize(this.lastSize.width, this.lastSize.height, true);\n          }\n          switch (key) {\n            case \"resolutionScale\":\n              this.setSize(this.lastSize.width, this.lastSize.height);\n              break;\n            case \"velocityResolutionScale\":\n              this.temporalResolvePass.velocityResolutionScale = value;\n              this.setSize(this.lastSize.width, this.lastSize.height, true);\n              break;\n            case \"blur\":\n              this.uniforms.get(\"blur\").value = value;\n              break;\n            case \"blurSharpness\":\n              this.uniforms.get(\"blurSharpness\").value = value;\n              break;\n            case \"blurKernel\":\n              this.uniforms.get(\"blurKernel\").value = value;\n              break;\n            // defines\n\n            case \"steps\":\n              this.reflectionsPass.fullscreenMaterial.defines.steps = parseInt(value);\n              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate;\n              break;\n            case \"refineSteps\":\n              this.reflectionsPass.fullscreenMaterial.defines.refineSteps = parseInt(value);\n              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate;\n              break;\n            case \"missedRays\":\n              if (value) {\n                this.reflectionsPass.fullscreenMaterial.defines.missedRays = \"\";\n              } else {\n                delete this.reflectionsPass.fullscreenMaterial.defines.missedRays;\n              }\n              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate;\n              break;\n            case \"correctionRadius\":\n              this.temporalResolvePass.fullscreenMaterial.defines.correctionRadius = Math.round(value);\n              this.temporalResolvePass.fullscreenMaterial.needsUpdate = needsUpdate;\n              break;\n            case \"blend\":\n              this.temporalResolvePass.fullscreenMaterial.uniforms.blend.value = value;\n              break;\n            case \"correction\":\n              this.temporalResolvePass.fullscreenMaterial.uniforms.correction.value = value;\n              break;\n            case \"exponent\":\n              this.temporalResolvePass.fullscreenMaterial.uniforms.exponent.value = value;\n              break;\n            case \"distance\":\n              reflectionPassFullscreenMaterialUniforms.rayDistance.value = value;\n            // must be a uniform\n\n            default:\n              if (reflectionPassFullscreenMaterialUniformsKeys.includes(key)) {\n                reflectionPassFullscreenMaterialUniforms[key].value = value;\n              }\n          }\n        }\n      }); // apply all uniforms and defines\n\n      this[key] = options[key];\n    }\n    needsUpdate = true;\n  }\n  setSize(width, height) {\n    let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!force && width === this.lastSize.width && height === this.lastSize.height && this.resolutionScale === this.lastSize.resolutionScale && this.velocityResolutionScale === this.lastSize.velocityResolutionScale) return;\n    this.temporalResolvePass.setSize(width, height);\n    this.reflectionsPass.setSize(width, height);\n    this.lastSize = {\n      width,\n      height,\n      resolutionScale: this.resolutionScale,\n      velocityResolutionScale: this.velocityResolutionScale\n    };\n  }\n  generateBoxProjectedEnvMapFallback(renderer) {\n    let position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n    let size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();\n    let envMapSize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 512;\n    this.cubeCamera.renderTarget.dispose();\n    this.cubeCamera.renderTarget = new WebGLCubeRenderTarget(envMapSize);\n    this.cubeCamera.position.copy(position);\n    this.cubeCamera.updateMatrixWorld();\n    this.cubeCamera.update(renderer, this._scene);\n    if (!pmremGenerator) {\n      pmremGenerator = new PMREMGenerator(renderer);\n      pmremGenerator.compileCubemapShader();\n    }\n    const envMap = pmremGenerator.fromCubemap(this.cubeCamera.renderTarget.texture).texture;\n    envMap.minFilter = LinearFilter;\n    envMap.magFilter = LinearFilter;\n    const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial;\n    useBoxProjectedEnvMap(reflectionsMaterial, position, size);\n    reflectionsMaterial.fragmentShader = reflectionsMaterial.fragmentShader.replace(\"vec3 worldPos\", \"worldPos\").replace(\"varying vec3 vWorldPosition;\", \"vec3 worldPos;\");\n    reflectionsMaterial.uniforms.envMapPosition.value.copy(position);\n    reflectionsMaterial.uniforms.envMapSize.value.copy(size);\n    setupEnvMap(reflectionsMaterial, envMap, envMapSize);\n    this.usingBoxProjectedEnvMap = true;\n    return envMap;\n  }\n  setIBLRadiance(iblRadiance, renderer) {\n    this._scene.traverse(c => {\n      if (c.material) {\n        var _renderer$properties$;\n        const uniforms = (_renderer$properties$ = renderer.properties.get(c.material)) == null ? void 0 : _renderer$properties$.uniforms;\n        if (uniforms && \"disableIBLRadiance\" in uniforms) {\n          uniforms.disableIBLRadiance.value = iblRadiance;\n        }\n      }\n    });\n  }\n  deleteBoxProjectedEnvMapFallback() {\n    const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial;\n    reflectionsMaterial.uniforms.envMap.value = null;\n    reflectionsMaterial.fragmentShader = reflectionsMaterial.fragmentShader.replace(\"worldPos = \", \"vec3 worldPos = \");\n    delete reflectionsMaterial.defines.BOX_PROJECTED_ENV_MAP;\n    reflectionsMaterial.needsUpdate = true;\n    this.usingBoxProjectedEnvMap = false;\n  }\n  dispose() {\n    super.dispose();\n    this.reflectionsPass.dispose();\n    this.temporalResolvePass.dispose();\n  }\n  update(renderer, inputBuffer) {\n    if (!this.usingBoxProjectedEnvMap && this._scene.environment) {\n      const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial;\n      let envMap = null; // not sure if there is a cleaner way to find the internal texture of a CubeTexture (when used as scene environment)\n\n      this._scene.traverse(c => {\n        if (!envMap && c.material && !c.material.envMap) {\n          const properties = renderer.properties.get(c.material);\n          if (\"envMap\" in properties && properties.envMap instanceof Texture) envMap = properties.envMap;\n        }\n      });\n      if (envMap) {\n        const envMapCubeUVHeight = this._scene.environment.image.height;\n        setupEnvMap(reflectionsMaterial, envMap, envMapCubeUVHeight);\n      }\n    }\n    this.haltonIndex = (this.haltonIndex + 1) % this.haltonSequence.length;\n    const [x, y] = this.haltonSequence[this.haltonIndex];\n    const {\n      width,\n      height\n    } = this.lastSize;\n    this.temporalResolvePass.velocityPass.render(renderer); // jittering the view offset each frame reduces aliasing for the reflection\n\n    if (this._camera.setViewOffset) this._camera.setViewOffset(width, height, x, y, width, height); // render reflections of current frame\n\n    this.reflectionsPass.render(renderer, inputBuffer); // compose reflection of last and current frame into one reflection\n\n    this.temporalResolvePass.render(renderer);\n    this._camera.clearViewOffset();\n  }\n  static patchDirectEnvIntensity() {\n    let envMapIntensity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    if (envMapIntensity === 0) {\n      ShaderChunk.envmap_physical_pars_fragment = ShaderChunk.envmap_physical_pars_fragment.replace(\"vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\", \"vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) { return vec3(0.0);\");\n    } else {\n      ShaderChunk.envmap_physical_pars_fragment = ShaderChunk.envmap_physical_pars_fragment.replace(\"vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\", \"vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness ) * \" + envMapIntensity.toFixed(5) + \";\");\n    }\n  }\n}\nexport { SSREffect, defaultSSROptions };","map":{"version":3,"names":["Pass","RenderPass","DepthPass","Effect","Selection","ShaderMaterial","Uniform","Vector2","Matrix3","TangentSpaceNormalMap","GLSL3","Matrix4","Vector3","WebGLRenderTarget","LinearFilter","HalfFloatType","WebGLMultipleRenderTargets","ShaderChunk","Color","Quaternion","VideoTexture","DataTexture","RGBAFormat","FloatType","NearestFilter","FramebufferTexture","WebGLCubeRenderTarget","CubeCamera","PMREMGenerator","Texture","_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","boxBlur","finalSSRShader","helperFunctions","trCompose","MRTMaterial","constructor","type","defines","USE_UV","TEMPORAL_RESOLVE","uniforms","opacity","normalMap","normalScale","uvTransform","roughness","roughnessMap","vertexShader","fragmentShader","toneMapped","normalMapType","defineProperty","get","set","_","vertexShader$1","ReflectionsMaterial","inputTexture","accumulatedTexture","normalTexture","depthTexture","_projectionMatrix","_inverseProjectionMatrix","cameraMatrixWorld","cameraNear","cameraFar","rayDistance","intensity","roughnessFade","fade","thickness","ior","maxDepthDifference","jitter","jitterRoughness","maxRoughness","samples","envMap","envMapPosition","envMapSize","viewMatrix","steps","refineSteps","CUBEUV_TEXEL_WIDTH","CUBEUV_TEXEL_HEIGHT","CUBEUV_MAX_MIP","vWorldPosition","replace","depthWrite","depthTest","getVisibleChildren","object","queue","objects","mesh","shift","material","push","c","children","visible","generateCubeUVSize","parameters","imageHeight","envMapCubeUVHeight","maxMip","Math","log2","texelHeight","texelWidth","max","pow","setupEnvMap","reflectionsMaterial","value","envMapCubeUVSize","ENVMAP_TYPE_CUBE_UV","needsUpdate","isWebGL2Available","canvas","document","createElement","window","WebGL2RenderingContext","getContext","e","ReflectionsPass","ssrEffect","options","undefined","cachedMaterials","WeakMap","USE_MRT","webgl1DepthPass","visibleMeshes","_scene","_camera","fullscreenMaterial","isPerspectiveCamera","PERSPECTIVE_CAMERA","width","innerWidth","height","innerHeight","renderTarget","minFilter","magFilter","depthBuffer","renderPass","gBuffersRenderTarget","texture","setSize","temporalResolvePass","matrixWorld","projectionMatrix","projectionMatrixInverse","resolutionScale","dispose","velocityTexture","keepMaterialMapUpdated","mrtMaterial","originalMaterial","prop","define","setMRTMaterialInScene","cachedOriginalMaterial","map","metalnessMap","matrix","selection","size","has","unsetMRTMaterialInScene","_c$material","render","renderer","inputBuffer","setRenderTarget","near","far","copy","matrixWorldInverse","scene","camera","defaultSSROptions","exponent","distance","blend","correction","correctionRadius","blur","blurKernel","blurSharpness","missedRays","useNormalMap","useRoughnessMap","velocityResolutionScale","temporalResolve","TemporalResolveMaterial","customComposeShader","lastVelocityTexture","invTexSize","prev_skinning_pars_vertex","velocity_vertex","skinbase_vertex","beginnormal_vertex","skinnormal_vertex","defaultnormal_vertex","skinning_vertex","VelocityMaterial","prevVelocityMatrix","velocityMatrix","prevBoneTexture","interpolateGeometry","boneTexture","alphaTest","alphaMap","skinning_pars_vertex","isVelocityMaterial","backgroundColor","updateProperties","VelocityPass","_window","_window2","lastCameraTransform","position","quaternion","renderedMeshesThisFrame","renderedMeshesLastFrame","setVelocityMaterialInScene","_c$skeleton2","velocityMaterial","_c$skeleton","lastMatrixWorld","skeleton","saveBoneTexture","multiplyMatrices","modelViewMatrix","userData","needsUpdatedReflections","FULL_MOVEMENT","cameraMovedThisFrame","equals","USE_SKINNING","BONE_TEXTURE","image","data","_boneTexture","boneMatrices","slice","unsetVelocityMaterialInScene","_c$skeleton3","renderVelocity","background","clearColor","checkCameraMoved","moveDist","distanceToSquared","rotateDist","dot","zeroVec2","TemporalResolvePass","velocityPass","dilation","setupFramebuffers","checkCanUseSharedVelocityTexture","canUseSharedVelocityTexture","checkNeedsResample","copyFramebufferToTexture","halton","index","base","fraction","result","generateHalton23Points","count","end","escapeRegExp","string","worldposReplace","boxProjectDefinitions","getIBLIrradiance_patch","getIBLRadiance_patch","useBoxProjectedEnvMap","shader","BOX_PROJECTED_ENV_MAP","line1","RegExp","replaceAll","line2","envmap_physical_pars_fragment","finalFragmentShader","noResetSamplesProperties","defaultCubeRenderTarget","pmremGenerator","SSREffect","Map","haltonSequence","haltonIndex","lastSize","cubeCamera","usingBoxProjectedEnvMap","trOptions","reflectionsPass","makeOptionsReactive","reflectionPassFullscreenMaterialUniforms","reflectionPassFullscreenMaterialUniformsKeys","keys","includes","parseInt","round","force","generateBoxProjectedEnvMapFallback","updateMatrixWorld","update","compileCubemapShader","fromCubemap","setIBLRadiance","iblRadiance","traverse","_renderer$properties$","properties","disableIBLRadiance","deleteBoxProjectedEnvMapFallback","environment","x","y","setViewOffset","clearViewOffset","patchDirectEnvIntensity","envMapIntensity","toFixed"],"sources":["C:/Users/Dru/Documents/Personal Projects/threeJSBlenderBaby/node_modules/screen-space-reflections/dist/index.js"],"sourcesContent":["import { Pass, RenderPass, DepthPass, Effect, Selection } from 'postprocessing';\nimport { ShaderMaterial, Uniform, Vector2, Matrix3, TangentSpaceNormalMap, GLSL3, Matrix4, Vector3, WebGLRenderTarget, LinearFilter, HalfFloatType, WebGLMultipleRenderTargets, ShaderChunk, Color, Quaternion, VideoTexture, DataTexture, RGBAFormat, FloatType, NearestFilter, FramebufferTexture, WebGLCubeRenderTarget, CubeCamera, PMREMGenerator, Texture } from 'three';\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nvar boxBlur = \"#define GLSLIFY 1\\nuniform float blur;uniform float blurSharpness;uniform int blurKernel;vec3 denoise(vec3 center,sampler2D tex,vec2 uv,vec2 invTexSize,float blur,float blurSharpness,int blurKernel){vec3 color;float total;vec3 col;float weight;for(int x=-blurKernel;x<=blurKernel;x++){for(int y=-blurKernel;y<=blurKernel;y++){col=textureLod(tex,uv+vec2(x,y)*invTexSize,0.).rgb;weight=1.0-abs(dot(col-center,vec3(0.25)));weight=pow(weight,blurSharpness);color+=col*weight;total+=weight;}}return color/total;}\"; // eslint-disable-line\n\nvar finalSSRShader = \"#define GLSLIFY 1\\n#define MODE_DEFAULT 0\\n#define MODE_REFLECTIONS 1\\n#define MODE_RAW_REFLECTION 2\\n#define MODE_BLURRED_REFLECTIONS 3\\n#define MODE_INPUT 4\\n#define MODE_BLUR_MIX 5\\n#define FLOAT_EPSILON 0.00001\\nuniform sampler2D inputTexture;uniform sampler2D reflectionsTexture;uniform float samples;\\n#include <boxBlur>\\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 reflectionsTexel=texture2D(reflectionsTexture,vUv);ivec2 size=textureSize(reflectionsTexture,0);vec2 invTexSize=1./vec2(size.x,size.y);vec3 reflectionClr=reflectionsTexel.xyz;if(blur>FLOAT_EPSILON){vec3 blurredReflectionsColor=denoise(reflectionsTexel.rgb,reflectionsTexture,vUv,invTexSize,blur,blurSharpness,blurKernel);reflectionClr=mix(reflectionClr,blurredReflectionsColor.rgb,blur);}\\n#if RENDER_MODE == MODE_DEFAULT\\noutputColor=vec4(inputColor.rgb+reflectionClr,1.0);\\n#endif\\n#if RENDER_MODE == MODE_REFLECTIONS\\noutputColor=vec4(reflectionClr,1.0);\\n#endif\\n#if RENDER_MODE == MODE_RAW_REFLECTION\\noutputColor=vec4(reflectionsTexel.xyz,1.0);\\n#endif\\n#if RENDER_MODE == MODE_BLURRED_REFLECTIONS\\noutputColor=vec4(blurredReflectionsTexel.xyz,1.0);\\n#endif\\n#if RENDER_MODE == MODE_INPUT\\noutputColor=vec4(inputColor.xyz,1.0);\\n#endif\\n#if RENDER_MODE == MODE_BLUR_MIX\\noutputColor=vec4(vec3(blur),1.0);\\n#endif\\n}\"; // eslint-disable-line\n\nvar helperFunctions = \"#define GLSLIFY 1\\nvec3 getViewPosition(const float depth){float clipW=_projectionMatrix[2][3]*depth+_projectionMatrix[3][3];vec4 clipPosition=vec4((vec3(vUv,depth)-0.5)*2.0,1.0);clipPosition*=clipW;return(_inverseProjectionMatrix*clipPosition).xyz;}float getViewZ(const in float depth){\\n#ifdef PERSPECTIVE_CAMERA\\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\\n#else\\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\\n#endif\\n}vec3 screenSpaceToWorldSpace(const vec2 uv,const float depth){vec4 ndc=vec4((uv.x-0.5)*2.0,(uv.y-0.5)*2.0,(depth-0.5)*2.0,1.0);vec4 clip=_inverseProjectionMatrix*ndc;vec4 view=cameraMatrixWorld*(clip/clip.w);return view.xyz;}\\n#define Scale (vec3(0.8, 0.8, 0.8))\\n#define K (19.19)\\nvec3 hash(vec3 a){a=fract(a*Scale);a+=dot(a,a.yxz+K);return fract((a.xxy+a.yxx)*a.zyx);}float fresnel_dielectric_cos(float cosi,float eta){float c=abs(cosi);float g=eta*eta-1.0+c*c;float result;if(g>0.0){g=sqrt(g);float A=(g-c)/(g+c);float B=(c*(g+c)-1.0)/(c*(g-c)+1.0);result=0.5*A*A*(1.0+B*B);}else{result=1.0;}return result;}float fresnel_dielectric(vec3 Incoming,vec3 Normal,float eta){float cosine=dot(Incoming,Normal);return min(1.0,5.0*fresnel_dielectric_cos(cosine,eta));}\"; // eslint-disable-line\n\nvar trCompose = \"#define GLSLIFY 1\\n#define INV_EULER 0.36787944117144233\\nalpha=velocityDisocclusion<FLOAT_EPSILON ?(alpha+0.0075): 0.0;alpha=clamp(alpha,0.0,1.0);bool needsBlur=!didReproject||velocityDisocclusion>0.5;\\n#ifdef boxBlur\\nif(needsBlur)inputColor=boxBlurredColor;\\n#endif\\nif(alpha==1.0){outputColor=accumulatedColor;}else{float m=mix(alpha,1.0,blend);if(needsBlur)m=0.0;outputColor=accumulatedColor*m+inputColor*(1.0-m);}\"; // eslint-disable-line\n\n// WebGL2: will render normals to RGB channel of \"gNormal\" buffer, roughness to A channel of \"gNormal\" buffer, depth to RGBA channel of \"gDepth\" buffer\n// and velocity to \"gVelocity\" buffer\n\nclass MRTMaterial extends ShaderMaterial {\n  constructor() {\n    super({\n      type: \"MRTMaterial\",\n      defines: {\n        USE_UV: \"\",\n        TEMPORAL_RESOLVE: \"\"\n      },\n      uniforms: {\n        opacity: new Uniform(1),\n        normalMap: new Uniform(null),\n        normalScale: new Uniform(new Vector2(1, 1)),\n        uvTransform: new Uniform(new Matrix3()),\n        roughness: new Uniform(1),\n        roughnessMap: new Uniform(null)\n      },\n      vertexShader:\n      /* glsl */\n      `\n                #ifdef USE_MRT\n                 varying vec2 vHighPrecisionZW;\n                #endif\n                #define NORMAL\n                #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n                    varying vec3 vViewPosition;\n                #endif\n                #include <common>\n                #include <uv_pars_vertex>\n                #include <displacementmap_pars_vertex>\n                #include <normal_pars_vertex>\n                #include <morphtarget_pars_vertex>\n                #include <skinning_pars_vertex>\n                #include <logdepthbuf_pars_vertex>\n                #include <clipping_planes_pars_vertex>\n                void main() {\n                    #include <uv_vertex>\n                    #include <beginnormal_vertex>\n                    #include <morphnormal_vertex>\n                    #include <skinbase_vertex>\n                    #include <skinnormal_vertex>\n                    #include <defaultnormal_vertex>\n                    #include <normal_vertex>\n                    #include <begin_vertex>\n                    #include <morphtarget_vertex>\n                    #include <skinning_vertex>\n                    #include <displacementmap_vertex>\n                    #include <project_vertex>\n                    #include <logdepthbuf_vertex>\n                    #include <clipping_planes_vertex>\n                    #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n                        vViewPosition = - mvPosition.xyz;\n                    #endif\n                    #ifdef USE_MRT\n                        vHighPrecisionZW = gl_Position.zw;\n                    #endif \n                    #ifdef USE_UV\n                        vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n                    #endif\n                }\n            `,\n      fragmentShader:\n      /* glsl */\n      `\n                 #define NORMAL\n                #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n                    varying vec3 vViewPosition;\n                #endif\n                #include <packing>\n                #include <uv_pars_fragment>\n                #include <normal_pars_fragment>\n                #include <bumpmap_pars_fragment>\n                #include <normalmap_pars_fragment>\n                #include <logdepthbuf_pars_fragment>\n                #include <clipping_planes_pars_fragment>\n                #include <roughnessmap_pars_fragment>\n                \n                #ifdef USE_MRT\n                layout(location = 0) out vec4 gNormal;\n                layout(location = 1) out vec4 gDepth;\n                \n                varying vec2 vHighPrecisionZW;\n                #endif\n                uniform float roughness;\n                void main() {\n                    #include <clipping_planes_fragment>\n                    #include <logdepthbuf_fragment>\n                    #include <normal_fragment_begin>\n                    #include <normal_fragment_maps>\n\n                    float roughnessFactor = roughness;\n                    \n                    if(roughness > 10.0e9){\n                        roughnessFactor = 1.;\n                    }else{\n                        #ifdef useRoughnessMap\n                            vec4 texelRoughness = texture2D( roughnessMap, vUv );\n                            // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n                            roughnessFactor *= texelRoughness.g;\n                        #endif\n                    }\n\n                    vec3 normalColor = packNormalToRGB( normal );\n                    #ifdef USE_MRT\n                        float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n                        vec4 depthColor = packDepthToRGBA( fragCoordZ );\n                        gNormal = vec4( normalColor, roughnessFactor );\n                        gDepth = depthColor;\n                    #else\n                        gl_FragColor = vec4(normalColor, roughnessFactor);\n                    #endif\n                }\n            `,\n      toneMapped: false\n    });\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    Object.defineProperty(this, \"glslVersion\", {\n      get() {\n        return \"USE_MRT\" in this.defines ? GLSL3 : null;\n      },\n\n      set(_) {}\n\n    });\n  }\n\n}\n\nvar vertexShader$1 = \"#define GLSLIFY 1\\nvarying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}\"; // eslint-disable-line\n\nvar fragmentShader = \"#define GLSLIFY 1\\nvarying vec2 vUv;uniform sampler2D inputTexture;uniform sampler2D accumulatedTexture;uniform sampler2D normalTexture;uniform sampler2D depthTexture;uniform sampler2D envMap;uniform mat4 _projectionMatrix;uniform mat4 _inverseProjectionMatrix;uniform mat4 cameraMatrixWorld;uniform float cameraNear;uniform float cameraFar;uniform float rayDistance;uniform float intensity;uniform float maxDepthDifference;uniform float roughnessFade;uniform float maxRoughness;uniform float fade;uniform float thickness;uniform float ior;uniform float samples;uniform float jitter;uniform float jitterRoughness;\\n#define INVALID_RAY_COORDS vec2(-1.0);\\n#define EARLY_OUT_COLOR vec4(0.0, 0.0, 0.0, 1.0)\\n#define FLOAT_EPSILON 0.00001\\nfloat nearMinusFar;float nearMulFar;float farMinusNear;\\n#include <packing>\\n#include <helperFunctions>\\nvec2 RayMarch(vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference);vec2 BinarySearch(in vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference);float fastGetViewZ(const in float depth);vec3 getIBLRadiance(const in vec3 viewDir,const in vec3 normal,const in float roughness);void main(){vec4 depthTexel=textureLod(depthTexture,vUv,0.0);if(dot(depthTexel.rgb,depthTexel.rgb)<FLOAT_EPSILON){gl_FragColor=EARLY_OUT_COLOR;return;}float unpackedDepth=unpackRGBAToDepth(depthTexel);vec4 normalTexel=textureLod(normalTexture,vUv,0.0);float roughness=normalTexel.a;float specular=1.0-roughness;nearMinusFar=cameraNear-cameraFar;nearMulFar=cameraNear*cameraFar;farMinusNear=cameraFar-cameraNear;normalTexel.rgb=unpackRGBToNormal(normalTexel.rgb);float depth=fastGetViewZ(unpackedDepth);vec3 viewPos=getViewPosition(depth);vec3 viewDir=normalize(viewPos);vec3 viewNormal=normalTexel.xyz;vec3 worldPos=screenSpaceToWorldSpace(vUv,unpackedDepth);vec3 jitt=vec3(0.0);if(jitterRoughness!=0.0||jitter!=0.0){vec3 randomJitter=hash(50.0*samples*worldPos)-0.5;float spread=((2.0-specular)+roughness*jitterRoughness);float jitterMix=jitter*0.25+jitterRoughness*roughness;if(jitterMix>1.0)jitterMix=1.0;jitt=mix(vec3(0.0),randomJitter*spread,jitterMix);}viewNormal+=jitt;float fresnelFactor=fresnel_dielectric(viewDir,viewNormal,ior);vec3 iblRadiance=getIBLRadiance(-viewDir,viewNormal,0.)*fresnelFactor;float lastFrameAlpha=textureLod(accumulatedTexture,vUv,0.0).a;if(roughness>maxRoughness||(roughness>1.0-FLOAT_EPSILON&&roughnessFade>1.0-FLOAT_EPSILON)){gl_FragColor=vec4(iblRadiance,lastFrameAlpha);return;}vec3 reflected=reflect(viewDir,viewNormal);vec3 rayDir=reflected*-viewPos.z;vec3 hitPos=viewPos;float rayHitDepthDifference;vec2 coords=RayMarch(rayDir,hitPos,rayHitDepthDifference);if(coords.x==-1.0){gl_FragColor=vec4(iblRadiance,lastFrameAlpha);return;}vec4 SSRTexel=textureLod(inputTexture,coords.xy,0.0);vec4 SSRTexelReflected=textureLod(accumulatedTexture,coords.xy,0.0);vec3 SSR=SSRTexel.rgb+SSRTexelReflected.rgb;float roughnessFactor=mix(specular,1.0,max(0.0,1.0-roughnessFade));vec2 coordsNDC=(coords.xy*2.0-1.0);float screenFade=0.1;float maxDimension=min(1.0,max(abs(coordsNDC.x),abs(coordsNDC.y)));float reflectionIntensity=1.0-(max(0.0,maxDimension-screenFade)/(1.0-screenFade));reflectionIntensity=max(0.,reflectionIntensity);vec3 finalSSR=mix(iblRadiance,SSR,reflectionIntensity)*roughnessFactor;if(fade!=0.0){vec3 hitWorldPos=screenSpaceToWorldSpace(coords,rayHitDepthDifference);float reflectionDistance=distance(hitWorldPos,worldPos)+1.0;float opacity=1.0/(reflectionDistance*fade*0.1);if(opacity>1.0)opacity=1.0;finalSSR*=opacity;}finalSSR*=fresnelFactor*intensity;finalSSR=min(vec3(1.0),finalSSR);float alpha=hitPos.z==1.0 ? 1.0 : SSRTexelReflected.a;alpha=min(lastFrameAlpha,alpha);gl_FragColor=vec4(finalSSR,alpha);}vec2 RayMarch(vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference){dir=normalize(dir);dir*=rayDistance/float(steps);float depth;vec4 projectedCoord;vec4 lastProjectedCoord;float unpackedDepth;vec4 depthTexel;for(int i=0;i<steps;i++){hitPos+=dir;projectedCoord=_projectionMatrix*vec4(hitPos,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;\\n#ifndef missedRays\\nif(projectedCoord.x<0.0||projectedCoord.x>1.0||projectedCoord.y<0.0||projectedCoord.y>1.0){return INVALID_RAY_COORDS;}\\n#endif\\ndepthTexel=textureLod(depthTexture,projectedCoord.xy,0.0);unpackedDepth=unpackRGBAToDepth(depthTexel);depth=fastGetViewZ(unpackedDepth);rayHitDepthDifference=depth-hitPos.z;if(rayHitDepthDifference>=0.0&&rayHitDepthDifference<thickness){\\n#if refineSteps == 0\\nif(dot(depthTexel.rgb,depthTexel.rgb)<FLOAT_EPSILON)return INVALID_RAY_COORDS;\\n#else\\nreturn BinarySearch(dir,hitPos,rayHitDepthDifference);\\n#endif\\n}\\n#ifndef missedRays\\nif(hitPos.z>0.0){return INVALID_RAY_COORDS;}\\n#endif\\nlastProjectedCoord=projectedCoord;}hitPos.z=1.0;\\n#ifndef missedRays\\nreturn INVALID_RAY_COORDS;\\n#endif\\nrayHitDepthDifference=unpackedDepth;return projectedCoord.xy;}vec2 BinarySearch(in vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference){float depth;vec4 projectedCoord;vec2 lastMinProjectedCoordXY;float unpackedDepth;vec4 depthTexel;for(int i=0;i<refineSteps;i++){projectedCoord=_projectionMatrix*vec4(hitPos,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;depthTexel=textureLod(depthTexture,projectedCoord.xy,0.0);unpackedDepth=unpackRGBAToDepth(depthTexel);depth=fastGetViewZ(unpackedDepth);rayHitDepthDifference=depth-hitPos.z;dir*=0.5;if(rayHitDepthDifference>0.0){hitPos-=dir;}else{hitPos+=dir;}}if(dot(depthTexel.rgb,depthTexel.rgb)<FLOAT_EPSILON)return INVALID_RAY_COORDS;if(abs(rayHitDepthDifference)>maxDepthDifference)return INVALID_RAY_COORDS;projectedCoord=_projectionMatrix*vec4(hitPos,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;rayHitDepthDifference=unpackedDepth;return projectedCoord.xy;}float fastGetViewZ(const in float depth){\\n#ifdef PERSPECTIVE_CAMERA\\nreturn nearMulFar/(farMinusNear*depth-cameraFar);\\n#else\\nreturn depth*nearMinusFar-cameraNear;\\n#endif\\n}\\n#include <common>\\n#include <cube_uv_reflection_fragment>\\nvec3 getIBLRadiance(const in vec3 viewDir,const in vec3 normal,const in float roughness){\\n#if defined(ENVMAP_TYPE_CUBE_UV)\\nvec3 reflectVec=reflect(-viewDir,normal);reflectVec=normalize(mix(reflectVec,normal,roughness*roughness));reflectVec=inverseTransformDirection(reflectVec,viewMatrix);vec4 envMapColor=textureCubeUV(envMap,reflectVec,roughness);return envMapColor.rgb*intensity;\\n#else\\nreturn vec3(0.0);\\n#endif\\n}\"; // eslint-disable-line\n\nclass ReflectionsMaterial extends ShaderMaterial {\n  constructor() {\n    super({\n      type: \"ReflectionsMaterial\",\n      uniforms: {\n        inputTexture: new Uniform(null),\n        accumulatedTexture: new Uniform(null),\n        normalTexture: new Uniform(null),\n        depthTexture: new Uniform(null),\n        _projectionMatrix: new Uniform(new Matrix4()),\n        _inverseProjectionMatrix: new Uniform(new Matrix4()),\n        cameraMatrixWorld: new Uniform(new Matrix4()),\n        cameraNear: new Uniform(0),\n        cameraFar: new Uniform(0),\n        rayDistance: new Uniform(0),\n        intensity: new Uniform(0),\n        roughnessFade: new Uniform(0),\n        fade: new Uniform(0),\n        thickness: new Uniform(0),\n        ior: new Uniform(0),\n        maxDepthDifference: new Uniform(0),\n        jitter: new Uniform(0),\n        jitterRoughness: new Uniform(0),\n        maxRoughness: new Uniform(0),\n        samples: new Uniform(0),\n        envMap: new Uniform(null),\n        envMapPosition: new Uniform(new Vector3()),\n        envMapSize: new Uniform(new Vector3()),\n        viewMatrix: new Uniform(new Matrix4())\n      },\n      defines: {\n        steps: 20,\n        refineSteps: 5,\n        CUBEUV_TEXEL_WIDTH: 0,\n        CUBEUV_TEXEL_HEIGHT: 0,\n        CUBEUV_MAX_MIP: 0,\n        vWorldPosition: \"worldPos\"\n      },\n      fragmentShader: fragmentShader.replace(\"#include <helperFunctions>\", helperFunctions),\n      vertexShader: vertexShader$1,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false\n    });\n  }\n\n}\n\nconst getVisibleChildren = object => {\n  const queue = [object];\n  const objects = [];\n\n  while (queue.length !== 0) {\n    const mesh = queue.shift();\n    if (mesh.material) objects.push(mesh);\n\n    for (const c of mesh.children) {\n      if (c.visible) queue.push(c);\n    }\n  }\n\n  return objects;\n};\nconst generateCubeUVSize = parameters => {\n  const imageHeight = parameters.envMapCubeUVHeight;\n  if (imageHeight === null) return null;\n  const maxMip = Math.log2(imageHeight) - 2;\n  const texelHeight = 1.0 / imageHeight;\n  const texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));\n  return {\n    texelWidth,\n    texelHeight,\n    maxMip\n  };\n};\nconst setupEnvMap = (reflectionsMaterial, envMap, envMapCubeUVHeight) => {\n  reflectionsMaterial.uniforms.envMap.value = envMap;\n  const envMapCubeUVSize = generateCubeUVSize({\n    envMapCubeUVHeight\n  });\n  reflectionsMaterial.defines.ENVMAP_TYPE_CUBE_UV = \"\";\n  reflectionsMaterial.defines.CUBEUV_TEXEL_WIDTH = envMapCubeUVSize.texelWidth;\n  reflectionsMaterial.defines.CUBEUV_TEXEL_HEIGHT = envMapCubeUVSize.texelHeight;\n  reflectionsMaterial.defines.CUBEUV_MAX_MIP = envMapCubeUVSize.maxMip + \".0\";\n  reflectionsMaterial.needsUpdate = true;\n};\n\nconst isWebGL2Available = () => {\n  try {\n    const canvas = document.createElement(\"canvas\");\n    return !!(window.WebGL2RenderingContext && canvas.getContext(\"webgl2\"));\n  } catch (e) {\n    return false;\n  }\n};\n\nclass ReflectionsPass extends Pass {\n  constructor(ssrEffect, options = {}) {\n    super(\"ReflectionsPass\");\n    this.ssrEffect = void 0;\n    this.cachedMaterials = new WeakMap();\n    this.USE_MRT = false;\n    this.webgl1DepthPass = null;\n    this.visibleMeshes = [];\n    this.ssrEffect = ssrEffect;\n    this._scene = ssrEffect._scene;\n    this._camera = ssrEffect._camera;\n    this.fullscreenMaterial = new ReflectionsMaterial();\n    if (ssrEffect._camera.isPerspectiveCamera) this.fullscreenMaterial.defines.PERSPECTIVE_CAMERA = \"\";\n    const width = options.width || typeof window !== \"undefined\" ? window.innerWidth : 2000;\n    const height = options.height || typeof window !== \"undefined\" ? window.innerHeight : 1000;\n    this.renderTarget = new WebGLRenderTarget(width, height, {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      type: HalfFloatType,\n      depthBuffer: false\n    });\n    this.renderPass = new RenderPass(this._scene, this._camera);\n    this.USE_MRT = isWebGL2Available();\n\n    if (this.USE_MRT) {\n      // buffers: normal, depth (2), roughness will be written to the alpha channel of the normal buffer\n      this.gBuffersRenderTarget = new WebGLMultipleRenderTargets(width, height, 2, {\n        minFilter: LinearFilter,\n        magFilter: LinearFilter\n      });\n      this.normalTexture = this.gBuffersRenderTarget.texture[0];\n      this.depthTexture = this.gBuffersRenderTarget.texture[1];\n    } else {\n      // depth pass\n      this.webgl1DepthPass = new DepthPass(this._scene, this._camera);\n      this.webgl1DepthPass.renderTarget.minFilter = LinearFilter;\n      this.webgl1DepthPass.renderTarget.magFilter = LinearFilter;\n      this.webgl1DepthPass.renderTarget.texture.minFilter = LinearFilter;\n      this.webgl1DepthPass.renderTarget.texture.magFilter = LinearFilter;\n      this.webgl1DepthPass.setSize(typeof window !== \"undefined\" ? window.innerWidth : 2000, typeof window !== \"undefined\" ? window.innerHeight : 1000); // render normals (in the rgb channel) and roughness (in the alpha channel) in gBuffersRenderTarget\n\n      this.gBuffersRenderTarget = new WebGLRenderTarget(width, height, {\n        minFilter: LinearFilter,\n        magFilter: LinearFilter\n      });\n      this.normalTexture = this.gBuffersRenderTarget.texture;\n      this.depthTexture = this.webgl1DepthPass.texture;\n    } // set up uniforms\n\n\n    this.fullscreenMaterial.uniforms.normalTexture.value = this.normalTexture;\n    this.fullscreenMaterial.uniforms.depthTexture.value = this.depthTexture;\n    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssrEffect.temporalResolvePass.accumulatedTexture;\n    this.fullscreenMaterial.uniforms.cameraMatrixWorld.value = this._camera.matrixWorld;\n    this.fullscreenMaterial.uniforms._projectionMatrix.value = this._camera.projectionMatrix;\n    this.fullscreenMaterial.uniforms._inverseProjectionMatrix.value = this._camera.projectionMatrixInverse;\n  }\n\n  setSize(width, height) {\n    this.renderTarget.setSize(width * this.ssrEffect.resolutionScale, height * this.ssrEffect.resolutionScale);\n    this.gBuffersRenderTarget.setSize(width * this.ssrEffect.resolutionScale, height * this.ssrEffect.resolutionScale);\n    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssrEffect.temporalResolvePass.accumulatedTexture;\n    this.fullscreenMaterial.needsUpdate = true;\n  }\n\n  dispose() {\n    this.renderTarget.dispose();\n    this.gBuffersRenderTarget.dispose();\n    this.renderPass.dispose();\n    if (!this.USE_MRT) this.webgl1DepthPass.dispose();\n    this.fullscreenMaterial.dispose();\n    this.normalTexture = null;\n    this.depthTexture = null;\n    this.velocityTexture = null;\n  }\n\n  keepMaterialMapUpdated(mrtMaterial, originalMaterial, prop, define) {\n    if (this.ssrEffect[define]) {\n      if (originalMaterial[prop] !== mrtMaterial[prop]) {\n        mrtMaterial[prop] = originalMaterial[prop];\n        mrtMaterial.uniforms[prop].value = originalMaterial[prop];\n\n        if (originalMaterial[prop]) {\n          mrtMaterial.defines[define] = \"\";\n        } else {\n          delete mrtMaterial.defines[define];\n        }\n\n        mrtMaterial.needsUpdate = true;\n      }\n    } else if (mrtMaterial[prop] !== undefined) {\n      mrtMaterial[prop] = undefined;\n      mrtMaterial.uniforms[prop].value = undefined;\n      delete mrtMaterial.defines[define];\n      mrtMaterial.needsUpdate = true;\n    }\n  }\n\n  setMRTMaterialInScene() {\n    this.visibleMeshes = getVisibleChildren(this._scene);\n\n    for (const c of this.visibleMeshes) {\n      if (c.material) {\n        const originalMaterial = c.material;\n        let [cachedOriginalMaterial, mrtMaterial] = this.cachedMaterials.get(c) || [];\n\n        if (originalMaterial !== cachedOriginalMaterial) {\n          if (mrtMaterial) mrtMaterial.dispose();\n          mrtMaterial = new MRTMaterial();\n          if (this.USE_MRT) mrtMaterial.defines.USE_MRT = \"\";\n          mrtMaterial.normalScale = originalMaterial.normalScale;\n          mrtMaterial.uniforms.normalScale.value = originalMaterial.normalScale;\n          const map = originalMaterial.map || originalMaterial.normalMap || originalMaterial.roughnessMap || originalMaterial.metalnessMap;\n          if (map) mrtMaterial.uniforms.uvTransform.value = map.matrix;\n          this.cachedMaterials.set(c, [originalMaterial, mrtMaterial]);\n        } // update the child's MRT material\n\n\n        this.keepMaterialMapUpdated(mrtMaterial, originalMaterial, \"normalMap\", \"useNormalMap\");\n        this.keepMaterialMapUpdated(mrtMaterial, originalMaterial, \"roughnessMap\", \"useRoughnessMap\");\n        mrtMaterial.uniforms.roughness.value = this.ssrEffect.selection.size === 0 || this.ssrEffect.selection.has(c) ? originalMaterial.roughness || 0 : 10e10;\n        c.material = mrtMaterial;\n      }\n    }\n  }\n\n  unsetMRTMaterialInScene() {\n    for (const c of this.visibleMeshes) {\n      var _c$material;\n\n      if (((_c$material = c.material) == null ? void 0 : _c$material.type) === \"MRTMaterial\") {\n        c.visible = true; // set material back to the original one\n\n        const [originalMaterial] = this.cachedMaterials.get(c);\n        c.material = originalMaterial;\n      }\n    }\n  }\n\n  render(renderer, inputBuffer) {\n    this.setMRTMaterialInScene();\n    renderer.setRenderTarget(this.gBuffersRenderTarget);\n    this.renderPass.render(renderer, this.gBuffersRenderTarget);\n    this.unsetMRTMaterialInScene(); // render depth and velocity in seperate passes\n\n    if (!this.USE_MRT) this.webgl1DepthPass.renderPass.render(renderer, this.webgl1DepthPass.renderTarget);\n    this.fullscreenMaterial.uniforms.inputTexture.value = inputBuffer.texture;\n    this.fullscreenMaterial.uniforms.samples.value = this.ssrEffect.temporalResolvePass.samples;\n    this.fullscreenMaterial.uniforms.cameraNear.value = this._camera.near;\n    this.fullscreenMaterial.uniforms.cameraFar.value = this._camera.far;\n    this.fullscreenMaterial.uniforms.viewMatrix.value.copy(this._camera.matrixWorldInverse);\n    renderer.setRenderTarget(this.renderTarget);\n    renderer.render(this.scene, this.camera);\n  }\n\n}\n\n/**\n* Options of the SSR effect\n* @typedef {Object} SSROptions\n* @property {Number} [intensity] intensity of the reflections\n* @property {Number} [exponent] exponent by which reflections will be potentiated when composing the current frame's reflections and the accumulated reflections into a final reflection; higher values will make reflections clearer by highlighting darker spots less\n* @property {Number} [distance] maximum distance a reflection ray can travel to find what it reflects\n* @property {Number} [fade] how much reflections will fade out by distance\n* @property {Number} [roughnessFade] how intense reflections should be on rough spots; a higher value will make reflections fade out quicker on rough spots\n* @property {Number} [thickness] maximum depth difference between a ray and the particular depth at its screen position before refining with binary search; higher values will result in better performance\n* @property {Number} [ior] Index of Refraction, used for calculating fresnel; reflections tend to be more intense the steeper the angle between them and the viewer is, the ior parameter sets how much the intensity varies\n* @property {Number} [maxRoughness] maximum roughness a texel can have to have reflections calculated for it\n* @property {Number} [maxDepthDifference] maximum depth difference between a ray and the particular depth at its screen position after refining with binary search; higher values will result in better performance\n* @property {Number} [blend] a value between 0 and 1 to set how much the last frame's reflections should be blended in; higher values will result in less noisy reflections when moving the camera but a more smeary look\n* @property {boolean} [correction] how much pixels should be corrected when doing temporal resolving; higher values will result in less smearing but more noise\n* @property {boolean} [correctionRadius] how many surrounding pixels will be used for neighborhood clamping; a higher value can reduce noise when moving the camera but will result in less performance\n* @property {Number} [blur] how much the blurred reflections should be mixed with the raw reflections\n* @property {Number} [blurKernel] kernel size of the Box Blur Filter; higher kernel sizes will result in blurrier reflections with more artifacts\n* @property {Number} [blurSharpness] exponent of the Box Blur filter; higher values will result in more sharpness\n* @property {Number} [jitter] how intense jittering should be\n* @property {Number} [jitterRoughness] how intense jittering should be in relation to a material's roughness\n* @property {Number} [steps] number of steps a reflection ray can maximally do to find an object it intersected (and thus reflects)\n* @property {Number} [refineSteps] once we had our ray intersect something, we need to find the exact point in space it intersected and thus it reflects; this can be done through binary search with the given number of maximum steps\n* @property {boolean} [missedRays] if there should still be reflections for rays for which a reflecting point couldn't be found; enabling this will result in stretched looking reflections which can look good or bad depending on the angle\n* @property {boolean} [useNormalMap] if roughness maps should be taken account of when calculating reflections\n* @property {boolean} [useRoughnessMap] if normal maps should be taken account of when calculating reflections\n* @property {Number} [resolutionScale] resolution of the SSR effect, a resolution of 0.5 means the effect will be rendered at half resolution\n* @property {Number} [velocityResolutionScale] resolution of the velocity buffer, a resolution of 0.5 means velocity will be rendered at half resolution\n*/\n\n/**\n * The options of the SSR effect\n * @type {SSROptions}\n */\nconst defaultSSROptions = {\n  intensity: 1,\n  exponent: 1,\n  distance: 10,\n  fade: 0,\n  roughnessFade: 1,\n  thickness: 10,\n  ior: 1.45,\n  maxRoughness: 1,\n  maxDepthDifference: 10,\n  blend: 0.9,\n  correction: 1,\n  correctionRadius: 1,\n  blur: 0.5,\n  blurKernel: 1,\n  blurSharpness: 10,\n  jitter: 0,\n  jitterRoughness: 0,\n  steps: 20,\n  refineSteps: 5,\n  missedRays: true,\n  useNormalMap: true,\n  useRoughnessMap: true,\n  resolutionScale: 1,\n  velocityResolutionScale: 1\n};\n\nvar vertexShader = \"#define GLSLIFY 1\\nvarying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}\"; // eslint-disable-line\n\nvar temporalResolve = \"#define GLSLIFY 1\\nuniform sampler2D inputTexture;uniform sampler2D accumulatedTexture;uniform sampler2D velocityTexture;uniform sampler2D lastVelocityTexture;uniform float blend;uniform float correction;uniform float exponent;uniform float samples;uniform vec2 invTexSize;uniform mat4 curInverseProjectionMatrix;uniform mat4 curCameraMatrixWorld;uniform mat4 prevInverseProjectionMatrix;uniform mat4 prevCameraMatrixWorld;varying vec2 vUv;\\n#define MAX_NEIGHBOR_DEPTH_DIFFERENCE 0.001\\n#define FLOAT_EPSILON 0.00001\\n#define FLOAT_ONE_MINUS_EPSILON 0.99999\\nvec3 transformexponent;vec3 undoColorTransformExponent;vec3 transformColor(vec3 color){if(exponent==1.0)return color;return pow(abs(color),transformexponent);}vec3 undoColorTransform(vec3 color){if(exponent==1.0)return color;return max(pow(abs(color),undoColorTransformExponent),vec3(0.0));}void main(){if(exponent!=1.0){transformexponent=vec3(1.0/exponent);undoColorTransformExponent=vec3(exponent);}vec4 inputTexel=textureLod(inputTexture,vUv,0.0);vec4 accumulatedTexel;vec3 inputColor=transformColor(inputTexel.rgb);vec3 accumulatedColor;float alpha=inputTexel.a;float velocityDisocclusion;bool didReproject=false;\\n#ifdef boxBlur\\nvec3 boxBlurredColor=inputTexel.rgb;\\n#endif\\nvec4 velocity=textureLod(velocityTexture,vUv,0.0);bool isMoving=alpha<1.0||dot(velocity.xy,velocity.xy)>0.0;if(isMoving){vec3 minNeighborColor=inputColor;vec3 maxNeighborColor=inputColor;vec3 col;vec2 neighborUv;vec2 reprojectedUv=vUv-velocity.xy;vec4 lastVelocity=textureLod(lastVelocityTexture,reprojectedUv,0.0);float depth=velocity.b;float closestDepth=depth;float lastClosestDepth=lastVelocity.b;float neighborDepth;float lastNeighborDepth;for(int x=-correctionRadius;x<=correctionRadius;x++){for(int y=-correctionRadius;y<=correctionRadius;y++){if(x!=0||y!=0){neighborUv=vUv+vec2(x,y)*invTexSize;vec4 neigborVelocity=textureLod(velocityTexture,neighborUv,0.0);neighborDepth=neigborVelocity.b;col=textureLod(inputTexture,neighborUv,0.0).xyz;int absX=abs(x);int absY=abs(y);\\n#ifdef dilation\\nif(absX==1&&absY==1){if(neighborDepth>closestDepth){velocity=neigborVelocity;closestDepth=neighborDepth;}vec4 lastNeighborVelocity=textureLod(velocityTexture,vUv+vec2(x,y)*invTexSize,0.0);lastNeighborDepth=lastNeighborVelocity.b;if(neighborDepth>closestDepth){lastVelocity=lastNeighborVelocity;lastClosestDepth=lastNeighborDepth;}}\\n#endif\\nif(abs(depth-neighborDepth)<MAX_NEIGHBOR_DEPTH_DIFFERENCE){\\n#ifdef boxBlur\\nif(absX<=2&&absY<=2)boxBlurredColor+=col;\\n#endif\\ncol=transformColor(col);minNeighborColor=min(col,minNeighborColor);maxNeighborColor=max(col,maxNeighborColor);}}}}float velocityLength=length(lastVelocity.xy-velocity.xy);velocityDisocclusion=(velocityLength-0.000005)*10.0;velocityDisocclusion*=velocityDisocclusion;reprojectedUv=vUv-velocity.xy;\\n#ifdef boxBlur\\nfloat pxRadius=correctionRadius>5 ? 121.0 : pow(float(correctionRadius*2+1),2.0);boxBlurredColor/=pxRadius;boxBlurredColor=transformColor(boxBlurredColor);\\n#endif\\nif(reprojectedUv.x>=0.0&&reprojectedUv.x<=1.0&&reprojectedUv.y>=0.0&&reprojectedUv.y<=1.0){accumulatedTexel=textureLod(accumulatedTexture,reprojectedUv,0.0);accumulatedColor=transformColor(accumulatedTexel.rgb);vec3 clampedColor=clamp(accumulatedColor,minNeighborColor,maxNeighborColor);accumulatedColor=mix(accumulatedColor,clampedColor,correction);didReproject=true;}else{\\n#ifdef boxBlur\\naccumulatedColor=boxBlurredColor;\\n#else\\naccumulatedColor=inputColor;\\n#endif\\n}if(velocity.r>FLOAT_ONE_MINUS_EPSILON&&velocity.g>FLOAT_ONE_MINUS_EPSILON){alpha=0.0;velocityDisocclusion=1.0;}}else{accumulatedColor=transformColor(textureLod(accumulatedTexture,vUv,0.0).rgb);}vec3 outputColor=inputColor;\\n#include <custom_compose_shader>\\ngl_FragColor=vec4(undoColorTransform(outputColor),alpha);}\"; // eslint-disable-line\n\nclass TemporalResolveMaterial extends ShaderMaterial {\n  constructor(customComposeShader) {\n    const fragmentShader = temporalResolve.replace(\"#include <custom_compose_shader>\", customComposeShader);\n    super({\n      type: \"TemporalResolveMaterial\",\n      uniforms: {\n        inputTexture: new Uniform(null),\n        accumulatedTexture: new Uniform(null),\n        velocityTexture: new Uniform(null),\n        lastVelocityTexture: new Uniform(null),\n        samples: new Uniform(1),\n        blend: new Uniform(0.5),\n        correction: new Uniform(1),\n        exponent: new Uniform(1),\n        invTexSize: new Uniform(new Vector2())\n      },\n      defines: {\n        correctionRadius: 1\n      },\n      vertexShader,\n      fragmentShader\n    });\n  }\n\n}\n\n// this shader is from: https://github.com/gkjohnson/threejs-sandbox\n// a second set of bone information from the previou frame\n\nconst prev_skinning_pars_vertex =\n/* glsl */\n`\n\t\t#ifdef USE_SKINNING\n\t\t#ifdef BONE_TEXTURE\n\t\t\tuniform sampler2D prevBoneTexture;\n\t\t\tmat4 getPrevBoneMatrix( const in float i ) {\n\t\t\t\tfloat j = i * 4.0;\n\t\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\t\ty = dy * ( y + 0.5 );\n\t\t\t\tvec4 v1 = texture2D( prevBoneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\t\tvec4 v2 = texture2D( prevBoneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\t\tvec4 v3 = texture2D( prevBoneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\t\tvec4 v4 = texture2D( prevBoneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\t\treturn bone;\n\t\t\t}\n\t\t#else\n\t\t\tuniform mat4 prevBoneMatrices[ MAX_BONES ];\n\t\t\tmat4 getPrevBoneMatrix( const in float i ) {\n\t\t\t\tmat4 bone = prevBoneMatrices[ int(i) ];\n\t\t\t\treturn bone;\n\t\t\t}\n\t\t#endif\n\t\t#endif\n`; // Returns the body of the vertex shader for the velocity buffer and\n// outputs the position of the current and last frame positions\n\nconst velocity_vertex =\n/* glsl */\n`\n\t\tvec3 transformed;\n\n\t\t// Get the normal\n\t\t${ShaderChunk.skinbase_vertex}\n\t\t${ShaderChunk.beginnormal_vertex}\n\t\t${ShaderChunk.skinnormal_vertex}\n\t\t${ShaderChunk.defaultnormal_vertex}\n\n\t\t// Get the current vertex position\n\t\ttransformed = vec3( position );\n\t\t${ShaderChunk.skinning_vertex}\n\t\tnewPosition = velocityMatrix * vec4( transformed, 1.0 );\n\n\t\t// Get the previous vertex position\n\t\ttransformed = vec3( position );\n\t\t${ShaderChunk.skinbase_vertex.replace(/mat4 /g, \"\").replace(/getBoneMatrix/g, \"getPrevBoneMatrix\")}\n\t\t${ShaderChunk.skinning_vertex.replace(/vec4 /g, \"\")}\n\t\tprevPosition = prevVelocityMatrix * vec4( transformed, 1.0 );\n\n\t\tgl_Position = newPosition;\n`;\nclass VelocityMaterial extends ShaderMaterial {\n  constructor() {\n    super({\n      uniforms: {\n        prevVelocityMatrix: {\n          value: new Matrix4()\n        },\n        velocityMatrix: {\n          value: new Matrix4()\n        },\n        prevBoneTexture: {\n          value: null\n        },\n        interpolateGeometry: {\n          value: 0\n        },\n        intensity: {\n          value: 1\n        },\n        boneTexture: {\n          value: null\n        },\n        alphaTest: {\n          value: 0.0\n        },\n        map: {\n          value: null\n        },\n        alphaMap: {\n          value: null\n        },\n        opacity: {\n          value: 1.0\n        }\n      },\n      vertexShader:\n      /* glsl */\n      `\n                    #define MAX_BONES 1024\n                    \n                    ${ShaderChunk.skinning_pars_vertex}\n                    ${prev_skinning_pars_vertex}\n        \n                    uniform mat4 velocityMatrix;\n                    uniform mat4 prevVelocityMatrix;\n                    uniform float interpolateGeometry;\n                    varying vec4 prevPosition;\n                    varying vec4 newPosition;\n\t\t\t\t\tvarying vec2 vHighPrecisionZW;\n        \n                    void main() {\n        \n                        ${velocity_vertex}\n\n\t\t\t\t\t\tvHighPrecisionZW = gl_Position.zw;\n        \n                    }`,\n      fragmentShader:\n      /* glsl */\n      `\n                    uniform float intensity;\n                    varying vec4 prevPosition;\n                    varying vec4 newPosition;\n\t\t\t\t\tvarying vec2 vHighPrecisionZW;\n        \n                    void main() {\n\t\t\t\t\t\t#ifdef FULL_MOVEMENT\n\t\t\t\t\t\tgl_FragColor = vec4( 1., 1., 1. - gl_FragCoord.z, 0. );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t\t#endif\n\n                        vec2 pos0 = (prevPosition.xy / prevPosition.w) * 0.5 + 0.5;\n                        vec2 pos1 = (newPosition.xy / newPosition.w) * 0.5 + 0.5;\n        \n                        vec2 vel = pos1 - pos0;\n\n\t\t\t\t\t\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n                        \n                        gl_FragColor = vec4( vel, 1. - fragCoordZ, 0. );\n        \n                    }`\n    });\n    this.isVelocityMaterial = true;\n  }\n\n}\n\nconst backgroundColor = new Color(0);\nconst updateProperties = [\"visible\", \"wireframe\", \"side\"];\nclass VelocityPass extends Pass {\n  constructor(scene, camera) {\n    var _window, _window2;\n\n    super(\"VelocityPass\");\n    this.cachedMaterials = new WeakMap();\n    this.lastCameraTransform = {\n      position: new Vector3(),\n      quaternion: new Quaternion()\n    };\n    this.visibleMeshes = [];\n    this.renderedMeshesThisFrame = 0;\n    this.renderedMeshesLastFrame = 0;\n    this._scene = scene;\n    this._camera = camera;\n    this.renderTarget = new WebGLRenderTarget(((_window = window) == null ? void 0 : _window.innerWidth) || 1000, ((_window2 = window) == null ? void 0 : _window2.innerHeight) || 1000, {\n      type: HalfFloatType\n    });\n  }\n\n  setVelocityMaterialInScene() {\n    this.renderedMeshesThisFrame = 0;\n    this.visibleMeshes = getVisibleChildren(this._scene);\n\n    for (const c of this.visibleMeshes) {\n      var _c$skeleton2;\n\n      const originalMaterial = c.material;\n      let [cachedOriginalMaterial, velocityMaterial] = this.cachedMaterials.get(c) || [];\n\n      if (originalMaterial !== cachedOriginalMaterial) {\n        var _c$skeleton;\n\n        velocityMaterial = new VelocityMaterial();\n        velocityMaterial.lastMatrixWorld = new Matrix4();\n        c.material = velocityMaterial;\n        if ((_c$skeleton = c.skeleton) != null && _c$skeleton.boneTexture) this.saveBoneTexture(c);\n        this.cachedMaterials.set(c, [originalMaterial, velocityMaterial]);\n      }\n\n      velocityMaterial.uniforms.velocityMatrix.value.multiplyMatrices(this._camera.projectionMatrix, c.modelViewMatrix);\n\n      if (c.userData.needsUpdatedReflections || originalMaterial.map instanceof VideoTexture) {\n        if (!(\"FULL_MOVEMENT\" in velocityMaterial.defines)) velocityMaterial.needsUpdate = true;\n        velocityMaterial.defines.FULL_MOVEMENT = \"\";\n      } else {\n        if (\"FULL_MOVEMENT\" in velocityMaterial.defines) {\n          delete velocityMaterial.defines.FULL_MOVEMENT;\n          velocityMaterial.needsUpdate = true;\n        }\n      }\n\n      c.visible = this.cameraMovedThisFrame || !c.matrixWorld.equals(velocityMaterial.lastMatrixWorld) || c.skeleton || \"FULL_MOVEMENT\" in velocityMaterial.defines;\n      c.material = velocityMaterial;\n      if (!c.visible) continue;\n      this.renderedMeshesThisFrame++;\n\n      for (const prop of updateProperties) velocityMaterial[prop] = originalMaterial[prop];\n\n      if ((_c$skeleton2 = c.skeleton) != null && _c$skeleton2.boneTexture) {\n        velocityMaterial.defines.USE_SKINNING = \"\";\n        velocityMaterial.defines.BONE_TEXTURE = \"\";\n        velocityMaterial.uniforms.boneTexture.value = c.skeleton.boneTexture;\n      }\n    }\n  }\n\n  saveBoneTexture(object) {\n    let boneTexture = object.material.uniforms.prevBoneTexture.value;\n\n    if (boneTexture && boneTexture.image.width === object.skeleton.boneTexture.width) {\n      boneTexture = object.material.uniforms.prevBoneTexture.value;\n      boneTexture.image.data.set(object.skeleton.boneTexture.image.data);\n    } else {\n      var _boneTexture;\n\n      (_boneTexture = boneTexture) == null ? void 0 : _boneTexture.dispose();\n      const boneMatrices = object.skeleton.boneTexture.image.data.slice();\n      const size = object.skeleton.boneTexture.image.width;\n      boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);\n      object.material.uniforms.prevBoneTexture.value = boneTexture;\n      boneTexture.needsUpdate = true;\n    }\n  }\n\n  unsetVelocityMaterialInScene() {\n    for (const c of this.visibleMeshes) {\n      if (c.material.isVelocityMaterial) {\n        var _c$skeleton3;\n\n        c.visible = true;\n        c.material.lastMatrixWorld.copy(c.matrixWorld);\n        c.material.uniforms.prevVelocityMatrix.value.multiplyMatrices(this._camera.projectionMatrix, c.modelViewMatrix);\n        if ((_c$skeleton3 = c.skeleton) != null && _c$skeleton3.boneTexture) this.saveBoneTexture(c);\n        c.material = this.cachedMaterials.get(c)[0];\n      }\n    }\n  }\n\n  setSize(width, height) {\n    this.renderTarget.setSize(width, height);\n  }\n\n  renderVelocity(renderer) {\n    renderer.setRenderTarget(this.renderTarget);\n\n    if (this.renderedMeshesThisFrame > 0) {\n      const {\n        background\n      } = this._scene;\n      this._scene.background = backgroundColor;\n      renderer.render(this._scene, this._camera);\n      this._scene.background = background;\n    } else {\n      renderer.clearColor();\n    }\n  }\n\n  checkCameraMoved() {\n    const moveDist = this.lastCameraTransform.position.distanceToSquared(this._camera.position);\n    const rotateDist = 8 * (1 - this.lastCameraTransform.quaternion.dot(this._camera.quaternion));\n\n    if (moveDist > 0.000001 || rotateDist > 0.000001) {\n      this.lastCameraTransform.position.copy(this._camera.position);\n      this.lastCameraTransform.quaternion.copy(this._camera.quaternion);\n      return true;\n    }\n\n    return false;\n  }\n\n  render(renderer) {\n    this.cameraMovedThisFrame = this.checkCameraMoved();\n    this.setVelocityMaterialInScene();\n    if (this.renderedMeshesThisFrame > 0 || this.renderedMeshesLastFrame > 0) this.renderVelocity(renderer);\n    this.unsetVelocityMaterialInScene();\n    this.renderedMeshesLastFrame = this.renderedMeshesThisFrame;\n  }\n\n}\n\nconst zeroVec2 = new Vector2(); // the following variables can be accessed by the custom compose shader:\n// \"inputTexel\", \"accumulatedTexel\", \"inputColor\", \"accumulatedColor\", \"alpha\", \"velocityDisocclusion\", \"didReproject\", \"boxBlurredColor\" (if using box blur)\n// the custom compose shader will write the final color to the variable \"outputColor\"\n\nclass TemporalResolvePass extends Pass {\n  constructor(scene, camera, customComposeShader, options = {}) {\n    super(\"TemporalResolvePass\");\n    this.velocityPass = null;\n    this.velocityResolutionScale = 1;\n    this.samples = 1;\n    this.lastCameraTransform = {\n      position: new Vector3(),\n      quaternion: new Quaternion()\n    };\n    this._scene = scene;\n    this._camera = camera;\n    this.renderTarget = new WebGLRenderTarget(1, 1, {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      type: HalfFloatType,\n      depthBuffer: false\n    });\n    this.velocityPass = new VelocityPass(scene, camera);\n    this.fullscreenMaterial = new TemporalResolveMaterial(customComposeShader);\n    this.fullscreenMaterial.defines.correctionRadius = options.correctionRadius || 1;\n    if (options.dilation) this.fullscreenMaterial.defines.dilation = \"\";\n    if (options.boxBlur) this.fullscreenMaterial.defines.boxBlur = \"\";\n    this.setupFramebuffers(1, 1);\n    this.checkCanUseSharedVelocityTexture();\n  }\n\n  dispose() {\n    if (this._scene.userData.velocityTexture === this.velocityPass.renderTarget.texture) {\n      delete this._scene.userData.velocityTexture;\n      delete this._scene.userData.lastVelocityTexture;\n    }\n\n    this.renderTarget.dispose();\n    this.accumulatedTexture.dispose();\n    this.fullscreenMaterial.dispose();\n    this.velocityPass.dispose();\n  }\n\n  setSize(width, height) {\n    this.renderTarget.setSize(width, height);\n    this.velocityPass.setSize(width * this.velocityResolutionScale, height * this.velocityResolutionScale);\n    this.velocityPass.renderTarget.texture.minFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;\n    this.velocityPass.renderTarget.texture.magFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;\n    this.velocityPass.renderTarget.texture.needsUpdate = true;\n    this.fullscreenMaterial.uniforms.invTexSize.value.set(1 / width, 1 / height);\n    this.setupFramebuffers(width, height);\n  }\n\n  setupFramebuffers(width, height) {\n    if (this.accumulatedTexture) this.accumulatedTexture.dispose();\n    if (this.lastVelocityTexture) this.lastVelocityTexture.dispose();\n    this.accumulatedTexture = new FramebufferTexture(width, height, RGBAFormat);\n    this.accumulatedTexture.minFilter = LinearFilter;\n    this.accumulatedTexture.magFilter = LinearFilter;\n    this.accumulatedTexture.type = HalfFloatType;\n    this.lastVelocityTexture = new FramebufferTexture(width * this.velocityResolutionScale, height * this.velocityResolutionScale, RGBAFormat);\n    this.lastVelocityTexture.minFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;\n    this.lastVelocityTexture.magFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;\n    this.lastVelocityTexture.type = HalfFloatType;\n    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.accumulatedTexture;\n    this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this.lastVelocityTexture;\n    this.fullscreenMaterial.needsUpdate = true;\n  }\n\n  checkCanUseSharedVelocityTexture() {\n    const canUseSharedVelocityTexture = this._scene.userData.velocityTexture && this.velocityPass.renderTarget.texture !== this._scene.userData.velocityTexture;\n\n    if (canUseSharedVelocityTexture) {\n      // let's use the shared one instead\n      if (this.velocityPass.renderTarget.texture === this.fullscreenMaterial.uniforms.velocityTexture.value) {\n        this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this._scene.userData.lastVelocityTexture;\n        this.fullscreenMaterial.uniforms.velocityTexture.value = this._scene.userData.velocityTexture;\n        this.fullscreenMaterial.needsUpdate = true;\n      }\n    } else {\n      // let's stop using the shared one (if used) and mark ours as the shared one instead\n      if (this.velocityPass.renderTarget.texture !== this.fullscreenMaterial.uniforms.velocityTexture.value) {\n        this.fullscreenMaterial.uniforms.velocityTexture.value = this.velocityPass.renderTarget.texture;\n        this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this.lastVelocityTexture;\n        this.fullscreenMaterial.needsUpdate = true;\n\n        if (!this._scene.userData.velocityTexture) {\n          this._scene.userData.velocityTexture = this.velocityPass.renderTarget.texture;\n          this._scene.userData.lastVelocityTexture = this.lastVelocityTexture;\n        }\n      }\n    }\n\n    return this.velocityPass.renderTarget.texture !== this.fullscreenMaterial.uniforms.velocityTexture.value;\n  }\n\n  checkNeedsResample() {\n    const moveDist = this.lastCameraTransform.position.distanceToSquared(this._camera.position);\n    const rotateDist = 8 * (1 - this.lastCameraTransform.quaternion.dot(this._camera.quaternion));\n\n    if (moveDist > 0.000001 || rotateDist > 0.000001) {\n      this.samples = 1;\n      this.lastCameraTransform.position.copy(this._camera.position);\n      this.lastCameraTransform.quaternion.copy(this._camera.quaternion);\n    }\n  }\n\n  render(renderer) {\n    this.samples++;\n    this.checkNeedsResample();\n    this.fullscreenMaterial.uniforms.samples.value = this.samples; // const isUsingSharedVelocityTexture = this.checkCanUseSharedVelocityTexture()\n    // if (!isUsingSharedVelocityTexture) this.velocityPass.render(renderer)\n\n    renderer.setRenderTarget(this.renderTarget);\n    renderer.render(this.scene, this.camera); // save the render target's texture for use in next frame\n\n    renderer.copyFramebufferToTexture(zeroVec2, this.accumulatedTexture);\n    renderer.setRenderTarget(this.velocityPass.renderTarget);\n    renderer.copyFramebufferToTexture(zeroVec2, this.lastVelocityTexture);\n  }\n\n}\n\n// source: https://observablehq.com/@jrus/halton\nconst halton = function halton(index, base) {\n  let fraction = 1;\n  let result = 0;\n\n  while (index > 0) {\n    fraction /= base;\n    result += fraction * (index % base);\n    index = ~~(index / base); // floor division\n  }\n\n  return result;\n}; // generates Halton tuples in the range [-0.5:0.5]\n\n\nconst generateHalton23Points = count => {\n  const data = [];\n  let i = 1;\n  const end = i + count;\n\n  for (; i < end; i++) {\n    data.push([halton(i, 2) - 0.5, halton(i, 3) - 0.5]);\n  }\n\n  return data;\n};\n\n/* eslint-disable camelcase */\n\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n} // credits for the box-projecting shader code go to codercat (https://codercat.tk)\n\n\nconst worldposReplace =\n/* glsl */\n`\n#if defined( USE_ENVMAP ) || defined(  ) || defined ( USE_SHADOWMAP )\n    vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n    #ifdef BOX_PROJECTED_ENV_MAP\n        vWorldPosition = worldPosition.xyz;\n    #endif\n#endif\n`;\nconst boxProjectDefinitions =\n/* glsl */\n`\n#ifdef BOX_PROJECTED_ENV_MAP\n    uniform vec3 envMapSize;\n    uniform vec3 envMapPosition;\n    varying vec3 vWorldPosition;\n    \n    vec3 parallaxCorrectNormal( vec3 v, vec3 cubeSize, vec3 cubePos ) {\n        vec3 nDir = normalize( v );\n\n        vec3 rbmax = ( .5 * cubeSize + cubePos - vWorldPosition ) / nDir;\n        vec3 rbmin = ( -.5 * cubeSize + cubePos - vWorldPosition ) / nDir;\n\n        vec3 rbminmax;\n\n        rbminmax.x = ( nDir.x > 0. ) ? rbmax.x : rbmin.x;\n        rbminmax.y = ( nDir.y > 0. ) ? rbmax.y : rbmin.y;\n        rbminmax.z = ( nDir.z > 0. ) ? rbmax.z : rbmin.z;\n\n        float correction = min( min( rbminmax.x, rbminmax.y ), rbminmax.z );\n        vec3 boxIntersection = vWorldPosition + nDir * correction;\n        \n        return boxIntersection - cubePos;\n    }\n#endif\n`; // will be inserted after \"vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\"\n\nconst getIBLIrradiance_patch =\n/* glsl */\n`\n#ifdef BOX_PROJECTED_ENV_MAP\n    worldNormal = parallaxCorrectNormal( worldNormal, envMapSize, envMapPosition );\n#endif\n`; // will be inserted after \"reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\"\n\nconst getIBLRadiance_patch =\n/* glsl */\n`\n#ifdef BOX_PROJECTED_ENV_MAP\n    reflectVec = parallaxCorrectNormal( reflectVec, envMapSize, envMapPosition );\n#endif\n`;\nfunction useBoxProjectedEnvMap(shader, envMapPosition, envMapSize) {\n  // defines\n  shader.defines.BOX_PROJECTED_ENV_MAP = \"\"; // uniforms\n\n  shader.uniforms.envMapPosition = {\n    value: envMapPosition\n  };\n  shader.uniforms.envMapSize = {\n    value: envMapSize\n  };\n  const line1 = new RegExp(escapeRegExp(\"vec3 worldNormal = inverseTransformDirection ( normal , viewMatrix ) ;\").replaceAll(\" \", \"\\\\s*\"), \"g\");\n  const line2 = new RegExp(escapeRegExp(\"reflectVec = inverseTransformDirection ( reflectVec , viewMatrix ) ;\").replaceAll(\" \", \"\\\\s*\"), \"g\"); // vertex shader\n\n  shader.vertexShader = \"varying vec3 vWorldPosition;\\n\" + shader.vertexShader.replace(\"#include <worldpos_vertex>\", worldposReplace); // fragment shader\n\n  shader.fragmentShader = boxProjectDefinitions + \"\\n\" + shader.fragmentShader.replace(\"#include <envmap_physical_pars_fragment>\", ShaderChunk.envmap_physical_pars_fragment).replace(line1, `vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n                ${getIBLIrradiance_patch}`).replace(line2, `reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n                ${getIBLRadiance_patch}`);\n}\n\nconst finalFragmentShader = finalSSRShader.replace(\"#include <helperFunctions>\", helperFunctions).replace(\"#include <boxBlur>\", boxBlur); // all the properties for which we don't have to resample\n\nconst noResetSamplesProperties = [\"blur\", \"blurSharpness\", \"blurKernel\"];\nconst defaultCubeRenderTarget = new WebGLCubeRenderTarget(1);\nlet pmremGenerator;\nclass SSREffect extends Effect {\n  /**\n   * @param {THREE.Scene} scene The scene of the SSR effect\n   * @param {THREE.Camera} camera The camera with which SSR is being rendered\n   * @param {SSROptions} [options] The optional options for the SSR effect\n   */\n  constructor(scene, camera, options = defaultSSROptions) {\n    super(\"SSREffect\", finalFragmentShader, {\n      type: \"FinalSSRMaterial\",\n      uniforms: new Map([[\"reflectionsTexture\", new Uniform(null)], [\"blur\", new Uniform(0)], [\"blurSharpness\", new Uniform(0)], [\"blurKernel\", new Uniform(0)]]),\n      defines: new Map([[\"RENDER_MODE\", \"0\"]])\n    });\n    this.haltonSequence = generateHalton23Points(1024);\n    this.haltonIndex = 0;\n    this.selection = new Selection();\n    this.lastSize = void 0;\n    this.cubeCamera = new CubeCamera(0.001, 1000, defaultCubeRenderTarget);\n    this.usingBoxProjectedEnvMap = false;\n    this._scene = scene;\n    this._camera = camera;\n    const trOptions = {\n      boxBlur: true,\n      dilation: true\n    };\n    options = _extends({}, defaultSSROptions, options, trOptions); // set up passes\n    // temporal resolve pass\n\n    this.temporalResolvePass = new TemporalResolvePass(scene, camera, trCompose, options);\n    this.uniforms.get(\"reflectionsTexture\").value = this.temporalResolvePass.renderTarget.texture; // reflections pass\n\n    this.reflectionsPass = new ReflectionsPass(this, options);\n    this.temporalResolvePass.fullscreenMaterial.uniforms.inputTexture.value = this.reflectionsPass.renderTarget.texture;\n    this.lastSize = {\n      width: options.width,\n      height: options.height,\n      resolutionScale: options.resolutionScale,\n      velocityResolutionScale: options.velocityResolutionScale\n    };\n    this.setSize(options.width, options.height);\n    this.makeOptionsReactive(options);\n  }\n\n  makeOptionsReactive(options) {\n    let needsUpdate = false;\n    const reflectionPassFullscreenMaterialUniforms = this.reflectionsPass.fullscreenMaterial.uniforms;\n    const reflectionPassFullscreenMaterialUniformsKeys = Object.keys(reflectionPassFullscreenMaterialUniforms);\n\n    for (const key of Object.keys(options)) {\n      Object.defineProperty(this, key, {\n        get() {\n          return options[key];\n        },\n\n        set(value) {\n          if (options[key] === value && needsUpdate) return;\n          options[key] = value;\n\n          if (!noResetSamplesProperties.includes(key)) {\n            this.setSize(this.lastSize.width, this.lastSize.height, true);\n          }\n\n          switch (key) {\n            case \"resolutionScale\":\n              this.setSize(this.lastSize.width, this.lastSize.height);\n              break;\n\n            case \"velocityResolutionScale\":\n              this.temporalResolvePass.velocityResolutionScale = value;\n              this.setSize(this.lastSize.width, this.lastSize.height, true);\n              break;\n\n            case \"blur\":\n              this.uniforms.get(\"blur\").value = value;\n              break;\n\n            case \"blurSharpness\":\n              this.uniforms.get(\"blurSharpness\").value = value;\n              break;\n\n            case \"blurKernel\":\n              this.uniforms.get(\"blurKernel\").value = value;\n              break;\n            // defines\n\n            case \"steps\":\n              this.reflectionsPass.fullscreenMaterial.defines.steps = parseInt(value);\n              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate;\n              break;\n\n            case \"refineSteps\":\n              this.reflectionsPass.fullscreenMaterial.defines.refineSteps = parseInt(value);\n              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate;\n              break;\n\n            case \"missedRays\":\n              if (value) {\n                this.reflectionsPass.fullscreenMaterial.defines.missedRays = \"\";\n              } else {\n                delete this.reflectionsPass.fullscreenMaterial.defines.missedRays;\n              }\n\n              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate;\n              break;\n\n            case \"correctionRadius\":\n              this.temporalResolvePass.fullscreenMaterial.defines.correctionRadius = Math.round(value);\n              this.temporalResolvePass.fullscreenMaterial.needsUpdate = needsUpdate;\n              break;\n\n            case \"blend\":\n              this.temporalResolvePass.fullscreenMaterial.uniforms.blend.value = value;\n              break;\n\n            case \"correction\":\n              this.temporalResolvePass.fullscreenMaterial.uniforms.correction.value = value;\n              break;\n\n            case \"exponent\":\n              this.temporalResolvePass.fullscreenMaterial.uniforms.exponent.value = value;\n              break;\n\n            case \"distance\":\n              reflectionPassFullscreenMaterialUniforms.rayDistance.value = value;\n            // must be a uniform\n\n            default:\n              if (reflectionPassFullscreenMaterialUniformsKeys.includes(key)) {\n                reflectionPassFullscreenMaterialUniforms[key].value = value;\n              }\n\n          }\n        }\n\n      }); // apply all uniforms and defines\n\n      this[key] = options[key];\n    }\n\n    needsUpdate = true;\n  }\n\n  setSize(width, height, force = false) {\n    if (!force && width === this.lastSize.width && height === this.lastSize.height && this.resolutionScale === this.lastSize.resolutionScale && this.velocityResolutionScale === this.lastSize.velocityResolutionScale) return;\n    this.temporalResolvePass.setSize(width, height);\n    this.reflectionsPass.setSize(width, height);\n    this.lastSize = {\n      width,\n      height,\n      resolutionScale: this.resolutionScale,\n      velocityResolutionScale: this.velocityResolutionScale\n    };\n  }\n\n  generateBoxProjectedEnvMapFallback(renderer, position = new Vector3(), size = new Vector3(), envMapSize = 512) {\n    this.cubeCamera.renderTarget.dispose();\n    this.cubeCamera.renderTarget = new WebGLCubeRenderTarget(envMapSize);\n    this.cubeCamera.position.copy(position);\n    this.cubeCamera.updateMatrixWorld();\n    this.cubeCamera.update(renderer, this._scene);\n\n    if (!pmremGenerator) {\n      pmremGenerator = new PMREMGenerator(renderer);\n      pmremGenerator.compileCubemapShader();\n    }\n\n    const envMap = pmremGenerator.fromCubemap(this.cubeCamera.renderTarget.texture).texture;\n    envMap.minFilter = LinearFilter;\n    envMap.magFilter = LinearFilter;\n    const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial;\n    useBoxProjectedEnvMap(reflectionsMaterial, position, size);\n    reflectionsMaterial.fragmentShader = reflectionsMaterial.fragmentShader.replace(\"vec3 worldPos\", \"worldPos\").replace(\"varying vec3 vWorldPosition;\", \"vec3 worldPos;\");\n    reflectionsMaterial.uniforms.envMapPosition.value.copy(position);\n    reflectionsMaterial.uniforms.envMapSize.value.copy(size);\n    setupEnvMap(reflectionsMaterial, envMap, envMapSize);\n    this.usingBoxProjectedEnvMap = true;\n    return envMap;\n  }\n\n  setIBLRadiance(iblRadiance, renderer) {\n    this._scene.traverse(c => {\n      if (c.material) {\n        var _renderer$properties$;\n\n        const uniforms = (_renderer$properties$ = renderer.properties.get(c.material)) == null ? void 0 : _renderer$properties$.uniforms;\n\n        if (uniforms && \"disableIBLRadiance\" in uniforms) {\n          uniforms.disableIBLRadiance.value = iblRadiance;\n        }\n      }\n    });\n  }\n\n  deleteBoxProjectedEnvMapFallback() {\n    const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial;\n    reflectionsMaterial.uniforms.envMap.value = null;\n    reflectionsMaterial.fragmentShader = reflectionsMaterial.fragmentShader.replace(\"worldPos = \", \"vec3 worldPos = \");\n    delete reflectionsMaterial.defines.BOX_PROJECTED_ENV_MAP;\n    reflectionsMaterial.needsUpdate = true;\n    this.usingBoxProjectedEnvMap = false;\n  }\n\n  dispose() {\n    super.dispose();\n    this.reflectionsPass.dispose();\n    this.temporalResolvePass.dispose();\n  }\n\n  update(renderer, inputBuffer) {\n    if (!this.usingBoxProjectedEnvMap && this._scene.environment) {\n      const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial;\n      let envMap = null; // not sure if there is a cleaner way to find the internal texture of a CubeTexture (when used as scene environment)\n\n      this._scene.traverse(c => {\n        if (!envMap && c.material && !c.material.envMap) {\n          const properties = renderer.properties.get(c.material);\n          if (\"envMap\" in properties && properties.envMap instanceof Texture) envMap = properties.envMap;\n        }\n      });\n\n      if (envMap) {\n        const envMapCubeUVHeight = this._scene.environment.image.height;\n        setupEnvMap(reflectionsMaterial, envMap, envMapCubeUVHeight);\n      }\n    }\n\n    this.haltonIndex = (this.haltonIndex + 1) % this.haltonSequence.length;\n    const [x, y] = this.haltonSequence[this.haltonIndex];\n    const {\n      width,\n      height\n    } = this.lastSize;\n    this.temporalResolvePass.velocityPass.render(renderer); // jittering the view offset each frame reduces aliasing for the reflection\n\n    if (this._camera.setViewOffset) this._camera.setViewOffset(width, height, x, y, width, height); // render reflections of current frame\n\n    this.reflectionsPass.render(renderer, inputBuffer); // compose reflection of last and current frame into one reflection\n\n    this.temporalResolvePass.render(renderer);\n\n    this._camera.clearViewOffset();\n  }\n\n  static patchDirectEnvIntensity(envMapIntensity = 0) {\n    if (envMapIntensity === 0) {\n      ShaderChunk.envmap_physical_pars_fragment = ShaderChunk.envmap_physical_pars_fragment.replace(\"vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\", \"vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) { return vec3(0.0);\");\n    } else {\n      ShaderChunk.envmap_physical_pars_fragment = ShaderChunk.envmap_physical_pars_fragment.replace(\"vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\", \"vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness ) * \" + envMapIntensity.toFixed(5) + \";\");\n    }\n  }\n\n}\n\nexport { SSREffect, defaultSSROptions };\n"],"mappings":"AAAA,SAASA,IAAI,EAAEC,UAAU,EAAEC,SAAS,EAAEC,MAAM,EAAEC,SAAS,QAAQ,gBAAgB;AAC/E,SAASC,cAAc,EAAEC,OAAO,EAAEC,OAAO,EAAEC,OAAO,EAAEC,qBAAqB,EAAEC,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAEC,iBAAiB,EAAEC,YAAY,EAAEC,aAAa,EAAEC,0BAA0B,EAAEC,WAAW,EAAEC,KAAK,EAAEC,UAAU,EAAEC,YAAY,EAAEC,WAAW,EAAEC,UAAU,EAAEC,SAAS,EAAEC,aAAa,EAAEC,kBAAkB,EAAEC,qBAAqB,EAAEC,UAAU,EAAEC,cAAc,EAAEC,OAAO,QAAQ,OAAO;AAE9W,SAASC,QAAQA,CAAA,EAAG;EAClBA,QAAQ,GAAGC,MAAM,CAACC,MAAM,GAAGD,MAAM,CAACC,MAAM,CAACC,IAAI,EAAE,GAAG,UAAUC,MAAM,EAAE;IAClE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,SAAS,CAACC,MAAM,EAAEF,CAAC,EAAE,EAAE;MACzC,IAAIG,MAAM,GAAGF,SAAS,CAACD,CAAC,CAAC;MAEzB,KAAK,IAAII,GAAG,IAAID,MAAM,EAAE;QACtB,IAAIP,MAAM,CAACS,SAAS,CAACC,cAAc,CAACC,IAAI,CAACJ,MAAM,EAAEC,GAAG,CAAC,EAAE;UACrDL,MAAM,CAACK,GAAG,CAAC,GAAGD,MAAM,CAACC,GAAG,CAAC;QAC3B;MACF;IACF;IAEA,OAAOL,MAAM;EACf,CAAC;EACD,OAAOJ,QAAQ,CAACa,KAAK,CAAC,IAAI,EAAEP,SAAS,CAAC;AACxC;AAEA,IAAIQ,OAAO,GAAG,6fAA6f,CAAC,CAAC;;AAE7gB,IAAIC,cAAc,GAAG,uzCAAuzC,CAAC,CAAC;;AAE90C,IAAIC,eAAe,GAAG,osCAAosC,CAAC,CAAC;;AAE5tC,IAAIC,SAAS,GAAG,qaAAqa,CAAC,CAAC;;AAEvb;AACA;;AAEA,MAAMC,WAAW,SAAS3C,cAAc,CAAC;EACvC4C,WAAWA,CAAA,EAAG;IACZ,KAAK,CAAC;MACJC,IAAI,EAAE,aAAa;MACnBC,OAAO,EAAE;QACPC,MAAM,EAAE,EAAE;QACVC,gBAAgB,EAAE;MACpB,CAAC;MACDC,QAAQ,EAAE;QACRC,OAAO,EAAE,IAAIjD,OAAO,CAAC,CAAC,CAAC;QACvBkD,SAAS,EAAE,IAAIlD,OAAO,CAAC,IAAI,CAAC;QAC5BmD,WAAW,EAAE,IAAInD,OAAO,CAAC,IAAIC,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC3CmD,WAAW,EAAE,IAAIpD,OAAO,CAAC,IAAIE,OAAO,EAAE,CAAC;QACvCmD,SAAS,EAAE,IAAIrD,OAAO,CAAC,CAAC,CAAC;QACzBsD,YAAY,EAAE,IAAItD,OAAO,CAAC,IAAI;MAChC,CAAC;MACDuD,YAAY,EACZ;MACC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;MACPC,cAAc,EACd;MACC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;MACPC,UAAU,EAAE;IACd,CAAC,CAAC;IACF,IAAI,CAACC,aAAa,GAAGvD,qBAAqB;IAC1C,IAAI,CAACgD,WAAW,GAAG,IAAIlD,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;IACpCwB,MAAM,CAACkC,cAAc,CAAC,IAAI,EAAE,aAAa,EAAE;MACzCC,GAAGA,CAAA,EAAG;QACJ,OAAO,SAAS,IAAI,IAAI,CAACf,OAAO,GAAGzC,KAAK,GAAG,IAAI;MACjD,CAAC;MAEDyD,GAAGA,CAACC,CAAC,EAAE,CAAC;IAEV,CAAC,CAAC;EACJ;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"},"metadata":{},"sourceType":"module","externalDependencies":[]}